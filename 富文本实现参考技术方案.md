下面先把这张截图里**富文本的组成**拆开讲清楚，然后给出**基于 Texture（AsyncDisplayKit）+ Objective-C** 的可落地实现方案与关键代码。代码尽量保持“可直接粘贴进项目”的粒度，并兼顾你在做的流式 SSE、滚动性能等要求。

---

## 一、这张 UI 里富文本是怎么做出来的（从结果反推方案）

截图里可以拆成几个 Markdown 语义块，然后映射到对应的 UI 组件：

1. 标题

* “1. 基本语法”“2. 基本数据类型”——就是 `H2`/有序列表标题。
* 表现：较大的粗体、段前后间距。

2. 代码块卡片（重点）

* 源内容：`swift … ` 这样的 fenced code block。
* 视觉：卡片容器（圆角、阴影/分割线），**顶部工具栏**显示语言标签“swift”和“复制”按钮；下面是**等宽字体**的代码，带**语法高亮**和**行内注释**颜色。长行需要**横向滚动**，垂直方向随内容扩展。
* 交互：点“复制”把整段代码入剪贴板；长按选择；暗色/亮色主题联动。

3. 普通段落/列表/行内代码

* 行内代码用背景色+圆角+等宽字体；链接可点击；中文排版留足行高。

**实现路线（性能优先）**

* **解析**：在工作线程把 Markdown 流（边下边解析）切成语义块（标题、段落、代码块…）。
* **渲染**：每个语义块对应一个 *ASDisplayNode* 子树：标题用 `ASTextNode`，段落用 `ASTextNode`，代码块用自定义 `AICodeBlockNode`（内部组合 header + 横向 `ASScrollNode` + `ASTextNode`）。
* **语法高亮**：把代码文本 token 化，再转 `NSAttributedString`。为保证 Obj-C 纯实现与可控性能，下面给两条路：

  * 轻量方案：**基于正则**的语言高亮（够用且快，易扩展 Swift/Obj-C/JSON/Shell）。
  * 专业方案：接入 **tree-sitter（C 库）** 做词法/语法解析，暴露到 Obj-C（最稳但集成稍重）。
* **增量更新/流式**：消息还在生成时，先把已闭合的块渲染；处于\`\`\`围栏中的内容先作为“进行中代码块”，行到齐或 fence 结束再一次性高亮，减少频繁 relayout。
* **缓存**：以（language + code + theme）为 key，把高亮后的 attributed string 放 `NSCache`。

---

## 二、核心数据结构与解析（Objective-C）

### 1) 语义块模型

```objective-c
typedef NS_ENUM(NSInteger, AIMarkdownBlockType) {
  AIMarkdownBlockTypeParagraph,
  AIMarkdownBlockTypeHeading,     // level: 1..6
  AIMarkdownBlockTypeCodeBlock,   // language + code
  AIMarkdownBlockTypeListItem,
  AIMarkdownBlockTypeQuote
};

@interface AIMarkdownBlock : NSObject
@property (nonatomic) AIMarkdownBlockType type;
@property (nonatomic) NSInteger headingLevel;
@property (nonatomic, copy) NSString *text;       // 段落/标题文本
@property (nonatomic, copy) NSString *code;       // 代码文本
@property (nonatomic, copy) NSString *language;   // 代码语言
@end
```

### 2) 轻量 Markdown 逐行解析（支持 fenced code + 标题 + 段落）

````objective-c
@interface AIMarkdownParser : NSObject
- (NSArray<AIMarkdownBlock *> *)parse:(NSString *)raw;
@end

@implementation AIMarkdownParser
- (NSArray<AIMarkdownBlock *> *)parse:(NSString *)raw {
  NSMutableArray *blocks = [NSMutableArray array];
  NSArray<NSString *> *lines = [raw componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
  BOOL inFence = NO; NSString *lang = nil; NSMutableString *buf = nil;

  NSMutableString *para = [NSMutableString string];

  NSRegularExpression *fence = [NSRegularExpression regularExpressionWithPattern:@"^```\\s*([A-Za-z0-9+-]*)\\s*$" options:0 error:nil];
  NSRegularExpression *heading = [NSRegularExpression regularExpressionWithPattern:@"^(#{1,6})\\s+(.*)$" options:0 error:nil];

  void (^flushPara)(void) = ^{
    if (para.length > 0) {
      AIMarkdownBlock *b = [AIMarkdownBlock new];
      b.type = AIMarkdownBlockTypeParagraph;
      b.text = [para copy];
      [blocks addObject:b];
      [para setString:@""];
    }
  };

  for (NSString *line in lines) {
    NSTextCheckingResult *m = [fence firstMatchInString:line options:0 range:NSMakeRange(0, line.length)];
    if (m) {
      if (!inFence) {
        // 进入代码块
        flushPara();
        inFence = YES; buf = [NSMutableString string];
        NSRange langRange = [m rangeAtIndex:1];
        lang = (langRange.length > 0) ? [[line substringWithRange:langRange] lowercaseString] : @"";
      } else {
        // 结束代码块
        AIMarkdownBlock *b = [AIMarkdownBlock new];
        b.type = AIMarkdownBlockTypeCodeBlock;
        b.language = lang.length ? lang : @"plaintext";
        b.code = [buf copy];
        [blocks addObject:b];
        inFence = NO; lang = nil; buf = nil;
      }
      continue;
    }
    if (inFence) { [buf appendString:line]; [buf appendString:@"\n"]; continue; }

    NSTextCheckingResult *h = [heading firstMatchInString:line options:0 range:NSMakeRange(0, line.length)];
    if (h) {
      flushPara();
      NSInteger level = [line substringWithRange:[h rangeAtIndex:1]].length;
      NSString *title = [line substringWithRange:[h rangeAtIndex:2]];
      AIMarkdownBlock *b = [AIMarkdownBlock new];
      b.type = AIMarkdownBlockTypeHeading; b.headingLevel = level; b.text = title;
      [blocks addObject:b];
      continue;
    }

    if (line.length == 0) { flushPara(); }
    else {
      if (para.length) [para appendString:@"\n"];
      [para appendString:line];
    }
  }
  // 结尾
  if (inFence && buf.length) {
    AIMarkdownBlock *b = [AIMarkdownBlock new];
    b.type = AIMarkdownBlockTypeCodeBlock; b.language = lang ?: @"plaintext"; b.code = [buf copy];
    [blocks addObject:b];
  } else {
    flushPara();
  }
  return blocks;
}
@end
````

---

## 三、语法高亮（Objective-C，正则轻量版）

### 1) 主题与高亮器

```objective-c
@interface AICodeTheme : NSObject
@property (nonatomic) UIColor *bg;        // 代码块背景
@property (nonatomic) UIColor *border;
@property (nonatomic) UIColor *text;
@property (nonatomic) UIColor *keyword;
@property (nonatomic) UIColor *typeName;
@property (nonatomic) UIColor *string;
@property (nonatomic) UIColor *number;
@property (nonatomic) UIColor *comment;
@end

@interface AISyntaxHighlighter : NSObject
@property (nonatomic, strong) AICodeTheme *theme;
@property (nonatomic, strong) NSCache<NSString *, NSAttributedString *> *cache; // key: lang+hash
- (instancetype)initWithTheme:(AICodeTheme *)theme;
- (NSAttributedString *)highlightCode:(NSString *)code language:(NSString *)lang fontSize:(CGFloat)fontSize;
@end
```

```objective-c
@implementation AISyntaxHighlighter
- (instancetype)initWithTheme:(AICodeTheme *)theme {
  if (self = [super init]) { _theme = theme; _cache = [NSCache new]; }
  return self;
}

- (NSAttributedString *)highlightCode:(NSString *)code language:(NSString *)lang fontSize:(CGFloat)fontSize {
  NSString *cacheKey = [NSString stringWithFormat:@"%@:%lu", lang, (unsigned long)code.hash];
  NSAttributedString *cached = [self.cache objectForKey:cacheKey];
  if (cached) return cached;

  UIFont *mono = [UIFont monospacedSystemFontOfSize:fontSize weight:UIFontWeightRegular];
  NSMutableAttributedString *att = [[NSMutableAttributedString alloc] initWithString:code attributes:@{
    NSFontAttributeName: mono,
    NSForegroundColorAttributeName: self.theme.text
  }];

  // 通用 token
  NSArray<NSDictionary *> *rules = [self rulesForLanguage:lang];

  [rules enumerateObjectsUsingBlock:^(NSDictionary *r, NSUInteger idx, BOOL *stop) {
    NSString *pat = r[@"p"]; UIColor *color = r[@"c"]; NSInteger opts = [r[@"o"] integerValue];
    NSRegularExpression *re = [NSRegularExpression regularExpressionWithPattern:pat options:opts error:nil];
    [re enumerateMatchesInString:att.string options:0 range:NSMakeRange(0, att.length)
                      usingBlock:^(NSTextCheckingResult *m, NSMatchingFlags flags, BOOL *stop2) {
      if (m.range.location != NSNotFound && m.range.length > 0) {
        [att addAttributes:@{ NSForegroundColorAttributeName: color } range:m.range];
      }
    }];
  }];

  [self.cache setObject:att forKey:cacheKey];
  return att;
}

// 只示例 Swift/ObjC/JSON 的规则，其他语言可按需追加
- (NSArray<NSDictionary *> *)rulesForLanguage:(NSString *)lang {
  UIColor *kw = self.theme.keyword, *str = self.theme.string, *num = self.theme.number, *com = self.theme.comment, *type = self.theme.typeName;

  if ([lang isEqualToString:@"swift"]) {
    NSString *kwds = @"\\b(class|struct|enum|protocol|extension|func|let|var|if|else|for|while|repeat|switch|case|default|break|continue|return|import|guard|defer|in|do|try|catch|throw|throws|init|self|super|where|as|is|nil|true|false)\\b";
    return @[
      @{@"p": @"//.*?$", @"c": com,  @"o": @(NSRegularExpressionAnchorsMatchLines)},
      @{@"p": @"/\\*[\\s\\S]*?\\*/", @"c": com, @"o": @(0)},
      @{@"p": @"\"(\\\\.|[^\"\\\\])*\"", @"c": str, @"o": @(0)},
      @{@"p": kwds, @"c": kw, @"o": @(0)},
      @{@"p": @"\\b[A-Z][A-Za-z0-9_]*\\b", @"c": type, @"o": @(0)},
      @{@"p": @"\\b\\d+(?:\\.\\d+)?\\b", @"c": num, @"o": @(0)}
    ];
  } else if ([lang isEqualToString:@"objective-c"] || [lang isEqualToString:@"objc"]) {
    NSString *kwds = @"\\b(@interface|@implementation|@end|@property|@synthesize|@dynamic|@protocol|@optional|@required|id|instancetype|void|int|float|double|BOOL|if|else|for|while|switch|case|default|break|continue|return|typedef|struct|enum|sizeof|static|extern|const|volatile|__block)\\b";
    return @[
      @{@"p": @"//.*?$", @"c": com,  @"o": @(NSRegularExpressionAnchorsMatchLines)},
      @{@"p": @"/\\*[\\s\\S]*?\\*/", @"c": com, @"o": @(0)},
      @{@"p": @"@\"(\\\\.|[^\"\\\\])*\"", @"c": str, @"o": @(0)},
      @{@"p": kwds, @"c": kw, @"o": @(0)},
      @{@"p": @"\\b[A-Z][A-Za-z0-9_]*\\b", @"c": type, @"o": @(0)},
      @{@"p": @"\\b\\d+(?:\\.\\d+)?\\b", @"c": num, @"o": @(0)}
    ];
  } else if ([lang isEqualToString:@"json"]) {
    return @[
      @{@"p": @"\"(\\\\.|[^\"\\\\])*\"", @"c": str, @"o": @(0)},
      @{@"p": @"\\b\\d+(?:\\.\\d+)?\\b", @"c": num, @"o": @(0)},
      @{@"p": @"\\b(true|false|null)\\b", @"c": self.theme.keyword, @"o": @(0)}
    ];
  }
  // plaintext fallback：仅注释
  return @[@{@"p": @"//.*?$", @"c": com,  @"o": @(NSRegularExpressionAnchorsMatchLines)}];
}
@end
```

> 若要“专业语法树级别”的高亮，把 **tree-sitter** 的 C 库集成到项目（C 接口对 Obj-C 友好），解析出 token 范围后同样上色即可。性能很好，语言覆盖广。

---

## 四、渲染层：Texture 组件

### 1) 代码块节点（卡片 + 头部 + 横向滚动 + 文本）

```objective-c
@interface AICodeBlockNode : ASDisplayNode
- (instancetype)initWithCode:(NSString *)code language:(NSString *)lang highlighter:(AISyntaxHighlighter *)hl;
@end

@implementation AICodeBlockNode {
  AISyntaxHighlighter *_hl; NSString *_code; NSString *_lang;
  ASDisplayNode *_header;
  ASTextNode *_langNode;
  ASButtonNode *_copyBtn;
  ASScrollNode *_scroll;
  ASTextNode *_codeNode;
}

- (instancetype)initWithCode:(NSString *)code language:(NSString *)lang highlighter:(AISyntaxHighlighter *)hl {
  if (self = [super init]) {
    _hl = hl; _code = [code copy]; _lang = lang.length ? lang : @"plaintext";
    self.automaticallyManagesSubnodes = YES;
    self.backgroundColor = hl.theme.bg;
    self.cornerRadius = 12.0;
    self.clipsToBounds = YES;
    self.borderColor = hl.theme.border.CGColor;
    self.borderWidth = 0.5;

    _langNode = [ASTextNode new];
    _langNode.attributedText = [[NSAttributedString alloc] initWithString:_lang.uppercaseString
      attributes:@{ NSFontAttributeName: [UIFont systemFontOfSize:12 weight:UIFontWeightSemibold],
                    NSForegroundColorAttributeName: [UIColor secondaryLabelColor] }];

    _copyBtn = [ASButtonNode new];
    [_copyBtn setTitle:@"复制" withFont:[UIFont systemFontOfSize:12 weight:UIFontWeightSemibold] withColor:[UIColor labelColor] forState:UIControlStateNormal];
    [_copyBtn addTarget:self action:@selector(onCopy) forControlEvents:ASControlNodeEventTouchUpInside];

    _header = [ASDisplayNode new];
    _header.backgroundColor = [[UIColor secondarySystemBackgroundColor] colorWithAlphaComponent:0.7];

    _codeNode = [ASTextNode new];
    _codeNode.truncationMode = NSLineBreakByClipping;
    _codeNode.maximumNumberOfLines = 0;
    _codeNode.attributedText = [_hl highlightCode:_code language:_lang fontSize:14];

    _scroll = [[ASScrollNode alloc] init];
    _scroll.automaticallyManagesContentSize = YES;
    _scroll.view.showsHorizontalScrollIndicator = YES;
    _scroll.view.showsVerticalScrollIndicator = NO;
    _scroll.view.alwaysBounceHorizontal = YES;
    _scroll.style.flexGrow = 1.0;
    _scroll.automaticallyManagesSubnodes = YES;
    _scroll.layoutSpecBlock = ^ASLayoutSpec *(__kindof ASDisplayNode * _Nonnull node, ASSizeRange constrainedSize) {
      ASInsetLayoutSpec *inset = [ASInsetLayoutSpec insetLayoutSpecWithInsets:UIEdgeInsetsMake(8, 12, 8, 12) child:self->_codeNode];
      return inset;
    };
  }
  return self;
}

- (void)onCopy {
  if (_code.length) {
    [UIPasteboard generalPasteboard].string = _code;
    // 也可抛出 toast 事件
  }
}

- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize {
  ASStackLayoutSpec *headerRow =
    [ASStackLayoutSpec stackLayoutSpecWithDirection:ASStackLayoutDirectionHorizontal
                                            spacing:8
                                     justifyContent:ASStackLayoutJustifyContentSpaceBetween
                                         alignItems:ASStackLayoutAlignItemsCenter
                                           children:@[_langNode, _copyBtn]];
  headerRow.style.height = ASDimensionMake(32);

  ASInsetLayoutSpec *headerInset = [ASInsetLayoutSpec insetLayoutSpecWithInsets:UIEdgeInsetsMake(4, 12, 4, 12) child:headerRow];
  headerInset.child = headerRow;
  headerInset.style.preferredSize = CGSizeMake(constrainedSize.max.width, 32);

  ASStackLayoutSpec *v = [ASStackLayoutSpec verticalStackLayoutSpec];
  v.children = @[headerInset, _scroll];
  return v;
}
@end
```

### 2) 段落/标题节点（带行内代码渲染）

```objective-c
static NSAttributedString *ParagraphAttributedText(NSString *text, BOOL isHeading, NSInteger level) {
  CGFloat size = isHeading ? (level<=2 ? 22 : 18) : 16;
  UIFont *font = isHeading ? [UIFont systemFontOfSize:size weight:UIFontWeightSemibold]
                           : [UIFont systemFontOfSize:size];
  NSMutableParagraphStyle *ps = [NSMutableParagraphStyle new];
  ps.lineSpacing = isHeading ? 4 : 2;
  ps.paragraphSpacing = isHeading ? 8 : 6;

  // 行内 `code` 高亮
  NSMutableAttributedString *att = [[NSMutableAttributedString alloc] initWithString:text
    attributes:@{NSFontAttributeName:font, NSParagraphStyleAttributeName:ps}];

  NSRegularExpression *inlineCode = [NSRegularExpression regularExpressionWithPattern:@"`([^`]+)`" options:0 error:nil];
  NSArray<NSTextCheckingResult *> *matches = [inlineCode matchesInString:att.string options:0 range:NSMakeRange(0, att.length)];
  for (NSTextCheckingResult *m in [matches reverseObjectEnumerator]) {
    NSRange r = [m rangeAtIndex:1];
    NSString *code = [att.string substringWithRange:r];
    NSMutableAttributedString *frag = [[NSMutableAttributedString alloc] initWithString:code
      attributes:@{ NSFontAttributeName: [UIFont monospacedSystemFontOfSize:font.pointSize weight:UIFontWeightRegular],
                    NSBackgroundColorAttributeName: [UIColor colorWithWhite:0.92 alpha:1.0],
                    NSForegroundColorAttributeName: [UIColor labelColor]}];
    [att replaceCharactersInRange:m.range withAttributedString:frag];
  }
  return att;
}
```

### 3) 消息 Cell（把语义块拼起来）

```objective-c
@interface AIMessageNode : ASCellNode
- (instancetype)initWithMarkdown:(NSString *)markdown highlighter:(AISyntaxHighlighter *)hl;
@end

@implementation AIMessageNode {
  NSArray<AIMarkdownBlock *> *_blocks;
  AISyntaxHighlighter *_hl;
  ASStackLayoutSpec *_vstack;
}

- (instancetype)initWithMarkdown:(NSString *)markdown highlighter:(AISyntaxHighlighter *)hl {
  if (self = [super init]) {
    self.automaticallyManagesSubnodes = YES;
    _hl = hl;
    _blocks = [[AIMarkdownParser new] parse:markdown];
  }
  return self;
}

- (NSArray<ASLayoutElement *> *)_childrenNodes {
  NSMutableArray *children = [NSMutableArray array];
  for (AIMarkdownBlock *b in _blocks) {
    if (b.type == AIMarkdownBlockTypeHeading) {
      ASTextNode *t = [ASTextNode new];
      t.attributedText = ParagraphAttributedText(b.text, YES, b.headingLevel);
      [children addObject:t];
    } else if (b.type == AIMarkdownBlockTypeParagraph) {
      ASTextNode *t = [ASTextNode new];
      t.maximumNumberOfLines = 0;
      t.attributedText = ParagraphAttributedText(b.text, NO, 0);
      [children addObject:t];
    } else if (b.type == AIMarkdownBlockTypeCodeBlock) {
      AICodeBlockNode *code = [[AICodeBlockNode alloc] initWithCode:b.code language:b.language highlighter:_hl];
      [children addObject:code];
    }
  }
  return children;
}

- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize {
  ASStackLayoutSpec *v = [ASStackLayoutSpec verticalStackLayoutSpec];
  v.spacing = 10;
  v.children = [self _childrenNodes];
  ASInsetLayoutSpec *inset = [ASInsetLayoutSpec insetLayoutSpecWithInsets:UIEdgeInsetsMake(10, 12, 10, 12) child:v];
  return inset;
}
@end
```

### 4) 在 `ASTableNode`/`ASCollectionNode` 里使用

```objective-c
- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath {
  NSString *md = self.messages[indexPath.row].markdown; // 你流式累积的 Markdown 文本
  AICodeTheme *theme = [self currentTheme];
  AISyntaxHighlighter *hl = [[AISyntaxHighlighter alloc] initWithTheme:theme];

  return ^{
    AIMessageNode *node = [[AIMessageNode alloc] initWithMarkdown:md highlighter:hl];
    node.selectionStyle = UITableViewCellSelectionStyleNone;
    return node;
  };
}
```

---

## 五、主题/暗黑模式与配色

```objective-c
- (AICodeTheme *)currentTheme {
  AICodeTheme *t = [AICodeTheme new];
  BOOL dark = (UITraitCollection.currentTraitCollection.userInterfaceStyle == UIUserInterfaceStyleDark);
  if (dark) {
    t.bg = [UIColor colorWithWhite:0.12 alpha:1];
    t.border = [UIColor colorWithWhite:0.20 alpha:1];
    t.text = [UIColor colorWithWhite:0.90 alpha:1];
    t.keyword = [UIColor colorWithRed:0.78 green:0.62 blue:1 alpha:1];
    t.typeName = [UIColor colorWithRed:0.52 green:0.77 blue:1 alpha:1];
    t.string = [UIColor colorWithRed:1 green:0.59 blue:0.68 alpha:1];
    t.number = [UIColor colorWithRed:0.53 green:0.86 blue:0.63 alpha:1];
    t.comment = [UIColor colorWithWhite:0.65 alpha:1];
  } else {
    t.bg = [UIColor colorWithWhite:0.98 alpha:1];
    t.border = [UIColor colorWithWhite:0.90 alpha:1];
    t.text = [UIColor colorWithWhite:0.15 alpha:1];
    t.keyword = [UIColor colorWithRed:0.56 green:0.15 blue:0.75 alpha:1];
    t.typeName = [UIColor colorWithRed:0.15 green:0.35 blue:0.75 alpha:1];
    t.string = [UIColor colorWithRed:0.80 green:0.20 blue:0.25 alpha:1];
    t.number = [UIColor colorWithRed:0.00 green:0.45 blue:0.30 alpha:1];
    t.comment = [UIColor colorWithWhite:0.55 alpha:1];
  }
  return t;
}
```

> 如果需要像截图那样 **右上角“复制”图标** 与 **语言标签** 的 header，把 `AICodeBlockNode` 的 header 背景做成半透明条即可；也可以在 header 右侧加一个“折叠/展开”按钮做长代码折叠。

---

## 六、流式（SSE）生成的增量渲染建议

* **解析器可重入**：每次流入一段新文本时，**只对新增片段**跑一次 `parseIncremental`，把“打开未闭合的块”（尤其 code fence）继续累积，已闭合的块立即落地成节点。
* **避免频繁 relayout**：对正在显示的最后一条消息，节流（比如 50–100ms 合批）更新；代码块未闭合前暂不做高亮，只做等宽纯文本渲染，闭合后一并高亮（一次性属性运算最省）。
* **缓存**：对最终代码块的 attributed string 缓存；再次出现相同片段（LLM 常复述）直接命中。

---

## 七、可选的“专业版”替代件

* 解析：把 **cmark-gfm**（C 实现的 GitHub Markdown 语法）编译成静态库，用 Obj-C 包一层，拿到 AST 后你可以精准处理 `<pre><code class="language-swift">` 这种节点。
* 高亮：引入 **tree-sitter**（也是 C），Swift/Obj-C/JS/Python 等语言的语法库直接可用。把 token 范围映射到颜色更稳、更准确（尤其复杂语言特性）。
* 这样仍是 **纯 Obj-C 调用 C**，无需 Swift Bridge，与你的工程栈完全兼容。

---

## 八、落地核对清单

* [x] 标题/段落/行内代码渲染
* [x] 代码块卡片（圆角、header、复制、横向滚动、语法高亮）
* [x] 暗黑/明亮主题
* [x] SSE 流式增量解析与节流更新
* [x] NSCache 缓存高亮结果
* [x] Texture 异步布局，滚动流畅

---

如果你愿意，我可以把以上类（`AIMarkdownParser / AISyntaxHighlighter / AICodeBlockNode / AIMessageNode`）打成最小 demo（含 Podspec/静态库集成说明），或者改造成你现有的 `ASCellNode` 架构；也可以换成 **tree-sitter** 版本的高亮器。
