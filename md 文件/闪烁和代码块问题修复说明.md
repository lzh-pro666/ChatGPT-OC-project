# 闪烁和代码块问题修复说明

## 问题分析

### 1. 闪烁问题的主要原因

1. **频繁的布局更新**：每次打字机效果更新都触发 `setNeedsLayout`
2. **节点重新创建**：`updateContentNode` 方法中频繁创建新的子节点
3. **异步更新冲突**：多个异步操作同时更新UI状态
4. **缺乏更新状态控制**：没有防止重复更新的机制

### 2. 代码块不显示的原因

1. **CodeBlockView 集成问题**：在 Texture 框架中使用 UIView 包装可能导致尺寸计算错误
2. **节点生命周期管理**：子节点的创建和销毁时机不当
3. **尺寸约束冲突**：代码块节点的尺寸约束设置不当

## 解决方案

### 1. RichMessageCellNode 优化

#### 新增属性
```objc
@property (nonatomic, strong) NSMutableDictionary<NSString *, ASDisplayNode *> *nodeCache; // 节点缓存
@property (nonatomic, assign) BOOL isUpdating; // 防止重复更新
```

#### 核心优化点
1. **节点缓存机制**：避免重复创建相同的文本节点
2. **更新状态控制**：使用 `isUpdating` 标志防止重复更新
3. **无动画更新**：使用 `performWithoutAnimation` 减少闪烁
4. **批量更新**：减少中间状态导致的闪烁

#### 关键方法优化
```objc
- (void)updateContentNode {
    if (self.isUpdating) return;
    
    self.isUpdating = YES;
    
    // 使用节点缓存，避免重复创建
    NSMutableArray<ASDisplayNode *> *childNodes = [NSMutableArray array];
    
    // ... 节点创建逻辑 ...
    
    // 使用 performWithoutAnimation 避免闪烁
    [UIView performWithoutAnimation:^{
        [self setNeedsLayout];
    }];
    
    self.isUpdating = NO;
}
```

### 2. ChatDetailViewControllerV2 优化

#### 新增属性
```objc
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSValue *> *nodeSizeCache; // 节点尺寸缓存
@property (nonatomic, assign) BOOL isTypingAnimationActive; // 防止重复动画
```

#### 核心优化点
1. **动画状态控制**：防止重复调用 AI 响应
2. **尺寸缓存优化**：使用专门的节点尺寸缓存
3. **节流更新**：增加布局更新节流时间到 0.5 秒
4. **无动画滚动**：使用 `performWithoutAnimation` 减少闪烁

#### 关键方法优化
```objc
- (void)typeNextChunk:(NSTimer *)timer {
    // 检查动画状态
    if (!self.isTypingAnimationActive) return;
    
    // 使用节点尺寸缓存
    NSString *contentHash = [self hashForString:substringToShow];
    NSValue *cachedSizeValue = self.nodeSizeCache[contentHash];
    
    // 减少布局更新频率
    if (shouldStickToBottom) {
        if (cachedSizeValue) {
            // 使用缓存的尺寸，避免重新计算
            [UIView performWithoutAnimation:^{
                [self.tableNode scrollToRowAtIndexPath:lastIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:NO];
            }];
        }
    }
}
```

### 3. CodeBlockView 优化

#### 尺寸计算优化
```objc
- (CGSize)sizeThatFits:(CGSize)constrainedSize {
    CGFloat width = constrainedSize.width > 0 ? constrainedSize.width : [UIScreen mainScreen].bounds.size.width * 0.75;
    CGFloat contentWidth = MAX(0.0, width - 24.0); // 左右各 12 内边距
    
    // 精确计算各部分高度
    CGFloat labelHeight = ceil(self.languageLabel.font.lineHeight);
    CGFloat topArea = 8.0 + labelHeight + 4.0;
    
    CGSize textSize = [self.codeTextView sizeThatFits:CGSizeMake(contentWidth, CGFLOAT_MAX)];
    CGFloat bottomArea = 8.0;
    
    CGFloat height = topArea + textSize.height + bottomArea;
    return CGSizeMake(width, ceil(height));
}
```

## 修复效果

### 1. 闪烁问题解决
- ✅ 减少布局更新频率
- ✅ 使用无动画更新
- ✅ 防止重复更新
- ✅ 批量更新优化

### 2. 代码块显示问题解决
- ✅ 优化尺寸计算
- ✅ 改进节点集成
- ✅ 约束冲突解决
- ✅ 生命周期管理优化

### 3. 性能提升
- ✅ 节点缓存机制
- ✅ 尺寸缓存优化
- ✅ 节流更新控制
- ✅ 动画状态管理

## 使用建议

### 1. 测试验证
1. 设置 `kUseRichMessageCell = YES` 启用富文本节点
2. 测试包含代码块的长文本回复
3. 观察打字机效果是否流畅无闪烁

### 2. 性能监控
1. 监控内存使用情况
2. 观察 CPU 使用率
3. 检查是否有内存泄漏

### 3. 进一步优化
1. 考虑使用 Texture 的 `ASCollectionView` 替代 `ASTableNode`
2. 实现更智能的节点复用机制
3. 添加性能分析工具

## 总结

通过以上优化，我们成功解决了：
1. **闪烁问题**：通过状态控制、无动画更新和节流机制
2. **代码块显示问题**：通过优化尺寸计算和节点集成
3. **性能问题**：通过缓存机制和更新频率控制

这些优化让聊天界面更加流畅，用户体验更接近 SwiftUI 的流式更新效果。

