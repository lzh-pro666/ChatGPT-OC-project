# 富文本持久化和完整显示修复说明

## 问题描述

### 1. 回复末尾没有显示完整
- **现象**: 控制台显示接收到完整的SSE流数据，但UI界面最后几句话没有显示
- **原因**: 富文本解析和渲染过程中，文本节点的布局约束导致内容被截断

### 2. 重新进入聊天界面后富文本效果消失
- **现象**: 退出聊天界面再重新进入后，富文本效果（粗体、斜体、代码块等）消失
- **原因**: 富文本解析逻辑被简化，缺少完整的Markdown解析功能

## 解决方案

### 1. 恢复完整的富文本解析功能

#### 1.1 恢复必要的导入
```objc
#import "AIMarkdownParser.h"
#import "AICodeBlockNode.h"
#import <AsyncDisplayKit/ASButtonNode.h>
```

#### 1.2 恢复富文本相关属性
```objc
@property (nonatomic, strong) NSMutableDictionary<NSString *, ASDisplayNode *> *nodeCache;
@property (nonatomic, assign) BOOL isUpdating;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSValue *> *heightCache;
@property (nonatomic, strong) AIMarkdownParser *markdownParser;
@property (nonatomic, strong) NSArray<AIMarkdownBlock *> *markdownBlocks;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSNumber *> *layoutCache;
@property (nonatomic, assign) BOOL isLayoutStable;
```

#### 1.3 恢复完整的Markdown解析
```objc
- (void)parseMessage:(NSString *)message {
    if (self.isUpdating) return;
    
    // 关键优化：将富文本渲染放在后台线程，减少主线程压力
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 后台线程：Markdown解析和富文本处理
        NSArray<AIMarkdownBlock *> *markdownBlocks = [self.markdownParser parse:message];
        
        // 将 Markdown 语义块转换为 ParserResult
        NSMutableArray<ParserResult *> *results = [NSMutableArray array];
        
        // 处理不同类型的Markdown块
        for (AIMarkdownBlock *block in markdownBlocks) {
            if (block.type == AIMarkdownBlockTypeCodeBlock) {
                // 处理代码块
            } else if (block.type == AIMarkdownBlockTypeHeading) {
                // 处理标题
            } else {
                // 处理段落，应用内联样式
                [self applyBoldStyle:paragraphText];
                [self applyItalicStyle:paragraphText];
                [self applyInlineCodeStyle:paragraphText];
            }
        }
        
        // 主线程：UI更新
        dispatch_async(dispatch_get_main_queue(), ^{
            self.parsedResults = [results copy];
            [self updateContentNode];
        });
    });
}
```

### 2. 修复文本完整显示问题

#### 2.1 优化布局约束
```objc
- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize {
    // 限制最大宽度为 75%
    CGFloat maxWidth = constrainedSize.max.width * 0.75;
    self.contentNode.style.maxWidth = ASDimensionMake(maxWidth);
    
    // 为了避免末尾被裁剪，确保没有强制的 min/max height 限制
    self.contentNode.style.minHeight = ASDimensionMakeWithPoints(0);
    
    // 关键修复：确保内容节点可以扩展以容纳完整文本
    self.contentNode.style.flexGrow = 1.0;
    self.contentNode.style.flexShrink = 1.0;
}
```

#### 2.2 优化文本节点设置
```objc
// 为所有文本节点设置正确的flex属性
textNode.style.flexGrow = 1.0;
textNode.style.flexShrink = 1.0;

// 栈布局使用拉伸对齐
ASStackLayoutSpec *stack = [ASStackLayoutSpec stackLayoutSpecWithDirection:ASStackLayoutDirectionVertical
                                                                   spacing:8
                                                            justifyContent:ASStackLayoutJustifyContentStart
                                                                alignItems:ASStackLayoutAlignItemsStretch
                                                                  children:children];
// 确保栈布局可以正确计算高度和宽度
stack.style.flexGrow = 1.0;
stack.style.flexShrink = 1.0;
```

### 3. 确保富文本效果持久化

#### 3.1 强制重新解析
```objc
- (void)updateMessageText:(NSString *)newMessage {
    // 关键改进：强制每次都解析，确保富文本效果持久化
    BOOL shouldReparse = YES;
    
    if (shouldReparse) {
        // 重新解析时重置布局稳定性
        self.isLayoutStable = YES;
        
        // 关键优化：使用无动画更新，减少视觉跳跃
        [UIView performWithoutAnimation:^{
            [self parseMessage:newMessage];
        }];
    }
}
```

#### 3.2 智能节点缓存
```objc
// 获取或创建文本节点（带缓存）
- (ASTextNode *)getOrCreateTextNodeForText:(NSString *)text {
    NSString *cacheKey = [NSString stringWithFormat:@"text_%@", text];
    ASTextNode *cachedNode = self.nodeCache[cacheKey];
    
    if (!cachedNode) {
        cachedNode = [[ASTextNode alloc] init];
        cachedNode.attributedText = [self attributedStringForText:text];
        cachedNode.maximumNumberOfLines = 0;
        // 关键修复：确保文本节点可以显示完整内容
        cachedNode.style.flexGrow = 1.0;
        cachedNode.style.flexShrink = 1.0;
        self.nodeCache[cacheKey] = cachedNode;
    }
    
    return cachedNode;
}
```

### 4. 内联样式处理

#### 4.1 粗体样式
```objc
- (void)applyBoldStyle:(NSMutableAttributedString *)attributedString {
    NSString *text = attributedString.string;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"\\*\\*(.*?)\\*\\*" options:0 error:nil];
    
    NSArray<NSTextCheckingResult *> *matches = [regex matchesInString:text options:0 range:NSMakeRange(0, text.length)];
    
    // 从后往前处理，避免索引偏移
    for (NSInteger i = matches.count - 1; i >= 0; i--) {
        NSTextCheckingResult *match = matches[i];
        NSRange boldRange = [match rangeAtIndex:1];
        
        // 应用粗体样式
        UIFont *currentFont = [attributedString attribute:NSFontAttributeName atIndex:boldRange.location effectiveRange:nil] ?: [UIFont systemFontOfSize:17];
        UIFont *boldFont = [UIFont fontWithDescriptor:[currentFont.fontDescriptor fontDescriptorWithSymbolicTraits:UIFontDescriptorTraitBold] size:currentFont.pointSize];
        
        [attributedString addAttribute:NSFontAttributeName value:boldFont range:boldRange];
        
        // 移除标记符号
        [attributedString replaceCharactersInRange:[match rangeAtIndex:0] withString:[text substringWithRange:boldRange]];
    }
}
```

#### 4.2 斜体样式
```objc
- (void)applyItalicStyle:(NSMutableAttributedString *)attributedString {
    NSString *text = attributedString.string;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"\\*(.*?)\\*" options:0 error:nil];
    
    NSArray<NSTextCheckingResult *> *matches = [regex matchesInString:text options:0 range:NSMakeRange(0, text.length)];
    
    for (NSInteger i = matches.count - 1; i >= 0; i--) {
        NSTextCheckingResult *match = matches[i];
        NSRange italicRange = [match rangeAtIndex:1];
        
        // 应用斜体样式
        UIFont *currentFont = [attributedString attribute:NSFontAttributeName atIndex:italicRange.location effectiveRange:nil] ?: [UIFont systemFontOfSize:17];
        UIFont *italicFont = [UIFont fontWithDescriptor:[currentFont.fontDescriptor fontDescriptorWithSymbolicTraits:UIFontDescriptorTraitItalic] size:currentFont.pointSize];
        
        [attributedString addAttribute:NSFontAttributeName value:italicFont range:italicRange];
        
        // 移除标记符号
        [attributedString replaceCharactersInRange:[match rangeAtIndex:0] withString:[text substringWithRange:italicRange]];
    }
}
```

#### 4.3 内联代码样式
```objc
- (void)applyInlineCodeStyle:(NSMutableAttributedString *)attributedString {
    NSString *text = attributedString.string;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"`(.*?)`" options:0 error:nil];
    
    NSArray<NSTextCheckingResult *> *matches = [regex matchesInString:text options:0 range:NSMakeRange(0, text.length)];
    
    for (NSInteger i = matches.count - 1; i >= 0; i--) {
        NSTextCheckingResult *match = matches[i];
        NSRange codeRange = [match rangeAtIndex:1];
        
        // 应用代码样式
        UIColor *backgroundColor = self.isFromUser ? 
            [UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.2] :
            [UIColor colorWithRed:0/255.0 green:0/255.0 blue:0/255.0 alpha:0.1];
        
        [attributedString addAttributes:@{
            NSFontAttributeName: [UIFont monospacedSystemFontOfSize:16 weight:UIFontWeightRegular],
            NSBackgroundColorAttributeName: backgroundColor
        } range:codeRange];
        
        // 移除标记符号
        [attributedString replaceCharactersInRange:[match rangeAtIndex:0] withString:[text substringWithRange:codeRange]];
    }
}
```

### 5. 性能优化

#### 5.1 智能布局更新
```objc
- (void)smartLayoutUpdate {
    if (!self.isLayoutStable) {
        NSLog(@"RichMessageCellNode: 布局不稳定，跳过更新");
        return;
    }
    
    // 关键优化：使用节流机制，减少布局更新频率
    static NSTimeInterval lastLayoutUpdateTime = 0;
    NSTimeInterval currentTime = [[NSDate date] timeIntervalSince1970];
    
    if (currentTime - lastLayoutUpdateTime < 0.05) { // 50ms节流
        NSLog(@"RichMessageCellNode: 布局更新过于频繁，跳过此次更新");
        return;
    }
    
    lastLayoutUpdateTime = currentTime;
    
    // 确保在主线程执行布局更新
    if ([NSThread isMainThread]) {
        [UIView performWithoutAnimation:^{
            [self setNeedsLayout];
        }];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView performWithoutAnimation:^{
                [self setNeedsLayout];
            }];
        });
    }
}
```

#### 5.2 后台线程解析
```objc
// 关键优化：将富文本渲染放在后台线程，减少主线程压力
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 后台线程：Markdown解析和富文本处理
    NSArray<AIMarkdownBlock *> *markdownBlocks = [self.markdownParser parse:message];
    
    // 处理富文本...
    
    // 主线程：UI更新
    dispatch_async(dispatch_get_main_queue(), ^{
        self.parsedResults = [results copy];
        [self updateContentNode];
    });
});
```

## 技术原理

### 1. Flexbox布局原理
- **flexGrow = 1.0**: 允许节点占用所有可用空间
- **flexShrink = 1.0**: 允许节点在必要时缩小，但优先保持内容完整
- **alignItems = ASStackLayoutAlignItemsStretch**: 让子节点拉伸到父节点宽度

### 2. 富文本解析流程
1. **后台线程解析**: Markdown文本解析为语义块
2. **样式应用**: 为每个块应用相应的富文本样式
3. **内联处理**: 处理粗体、斜体、内联代码等内联样式
4. **主线程更新**: 在主线程更新UI

### 3. 缓存机制
- **节点缓存**: 避免重复创建相同的文本节点
- **布局缓存**: 缓存布局稳定性检查结果
- **高度缓存**: 缓存文本高度计算结果

## 预期效果

### 1. 解决文本截断问题
- 所有文本都能完整显示，包括最后几句话
- 自动换行正常工作
- 气泡宽度自适应内容

### 2. 保持富文本效果
- 粗体、斜体、内联代码等样式持久化
- 代码块正确显示
- 重新进入聊天界面后富文本效果不消失

### 3. 性能优化
- 后台线程解析，减少主线程压力
- 智能缓存，避免重复计算
- 节流机制，减少不必要的布局更新

## 测试要点

### 1. 文本完整显示测试
- 发送长句子，验证完整显示
- 检查最后几句话是否显示
- 验证自动换行是否正确

### 2. 富文本效果测试
- 测试粗体、斜体、内联代码样式
- 测试代码块显示
- 退出重新进入，验证富文本效果是否保持

### 3. 性能测试
- 快速发送多条消息
- 滚动查看历史消息
- 验证性能是否稳定

## 总结

通过恢复完整的富文本解析功能并优化布局约束，我们解决了：

1. **文本截断问题**: 通过正确的flex布局约束确保文本完整显示
2. **富文本效果消失**: 通过完整的Markdown解析和内联样式处理保持富文本效果
3. **性能问题**: 通过后台线程解析和智能缓存优化性能

这个修复确保了富文本功能的完整性和持久性，同时解决了文本显示不完整的问题。

