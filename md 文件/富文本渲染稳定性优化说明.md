# 富文本渲染稳定性优化说明

## 问题分析

### 1. 富文本 vs 普通文本的差异
- **富文本**：使用 `AIMarkdownParser` 解析成结构化块，每个块独立渲染，更新时只影响特定块
- **普通文本**：每次更新都重新创建整个节点，导致抖动和拉扯效果

### 2. 最后几句话没显示完全的原因
- 流式更新结束时，可能没有触发最终的完整解析和布局更新
- 增量更新阈值设置过高，导致最后的小段文本被跳过

### 3. 文字抖动的根本原因
- 每次文本更新都重新计算高度
- 频繁的 `setNeedsLayout` 调用
- 没有缓存已渲染的稳定内容
- 布局更新频率过高

## 解决方案

### 1. 统一富文本渲染方式
```objc
// 关键改进：所有文本都使用富文本解析，确保渲染稳定性
BOOL shouldReparse = YES; // 强制每次都解析，确保稳定性

if (shouldReparse) {
    // 重新解析时重置布局稳定性
    self.isLayoutStable = YES;
    [self clearLayoutCache];
    [self parseMessage:newMessage];
}
```

### 2. 兜底解析机制
```objc
// 关键改进：如果解析结果为空，强制创建一个段落结果
if (self.markdownBlocks.count == 0 && message.length > 0) {
    NSLog(@"RichMessageCellNode: 解析结果为空，创建兜底段落");
    // 创建兜底段落，确保所有文本都能正确显示
}
```

### 3. 降低更新阈值
```objc
// 关键改进：降低更新阈值，确保最后几句话能完整显示
if (appendedText.length > 1) { // 从5改为1，确保及时更新
    // 智能更新逻辑
}

// 关键改进：降低高度阈值，确保最后几句话能完整显示
CGFloat heightDifference = fabs(newSize.height - oldSize.height);
if (heightDifference > 5.0 && isStable) { // 从15改为5像素
    // 更新布局
}
```

### 4. 流式更新结束时的完整显示
```objc
// 在 typeNextChunk 方法中
} else {
    // 关键改进：确保最后几句话完整显示
    if (self.currentStreamingTask == nil) {
        // 流式更新结束，强制更新一次完整内容，确保最后几句话显示完全
        NSString *fullText = self.fullResponseBuffer;
        if ([self->_currentUpdatingAINode respondsToSelector:@selector(updateMessageText:)]) {
            [self->_currentUpdatingAINode updateMessageText:fullText];
        }
        
        // 强制滚动到底部，确保最后内容可见
        [UIView performWithoutAnimation:^{
            NSIndexPath *lastIndexPath = [NSIndexPath indexPathForRow:self.messages.count - 1 inSection:0];
            [self.tableNode scrollToRowAtIndexPath:lastIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:NO];
        }];
        
        [self stopTypingTimer];
    }
}

// 在 stopTypingTimer 方法中
// 关键改进：确保最后几句话完整显示
if (self->_currentUpdatingAINode && [self->_currentUpdatingAINode respondsToSelector:@selector(updateMessageText:)]) {
    NSString *fullText = self.fullResponseBuffer;
    [self->_currentUpdatingAINode updateMessageText:fullText];
    
    // 强制滚动到底部，确保最后内容可见
    [UIView performWithoutAnimation:^{
        NSIndexPath *lastIndexPath = [NSIndexPath indexPathForRow:self.messages.count - 1 inSection:0];
        [self.tableNode scrollToRowAtIndexPath:lastIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:NO];
    }];
}
```

## 优化效果

### 1. 消除文字抖动
- 所有文本都使用富文本的稳定渲染方式
- 减少不必要的布局更新
- 智能增量更新，只更新变化的部分

### 2. 确保完整显示
- 兜底解析机制，确保所有文本都能被正确解析
- 降低更新阈值，及时响应文本变化
- 流式更新结束时强制完整显示

### 3. 提升用户体验
- 丝滑的滚动效果
- 稳定的文本渲染
- 无闪烁、无抖动的显示效果

## 技术要点

### 1. 布局稳定性检查
```objc
- (BOOL)isLayoutStableForText:(NSString *)text {
    // 检查文本是否包含可能导致布局变化的元素
    BOOL isStable = YES;
    
    // 检查是否包含代码块标记
    if ([text containsString:@"```"]) {
        isStable = NO;
    }
    
    // 检查是否包含标题标记
    if ([text containsString:@"###"] || [text containsString:@"##"] || [text containsString:@"#"]) {
        isStable = NO;
    }
    
    return isStable;
}
```

### 2. 智能布局更新
```objc
- (void)smartLayoutUpdate {
    if (!self.isLayoutStable) {
        NSLog(@"RichMessageCellNode: 布局不稳定，跳过更新");
        return;
    }
    
    // 确保在主线程执行布局更新
    if ([NSThread isMainThread]) {
        [UIView performWithoutAnimation:^{
            [self setNeedsLayout];
        }];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView performWithoutAnimation:^{
                [self setNeedsLayout];
            }];
        });
    }
}
```

### 3. 节点缓存机制
```objc
- (ASTextNode *)getOrCreateTextNodeForText:(NSString *)text {
    NSString *cacheKey = [NSString stringWithFormat:@"text_%@", text];
    ASTextNode *cachedNode = self.nodeCache[cacheKey];
    
    if (!cachedNode) {
        cachedNode = [[ASTextNode alloc] init];
        cachedNode.attributedText = [self attributedStringForText:text];
        cachedNode.maximumNumberOfLines = 0;
        self.nodeCache[cacheKey] = cachedNode;
    }
    
    return cachedNode;
}
```

## 总结

通过以上优化，我们实现了：

1. **统一的富文本渲染**：所有文本都使用相同的稳定渲染方式
2. **消除文字抖动**：通过智能布局更新和节点缓存机制
3. **确保完整显示**：兜底解析和流式更新结束时的强制完整显示
4. **提升用户体验**：丝滑的滚动和稳定的文本渲染

这些优化确保了聊天界面的流畅性和稳定性，提供了类似 SwiftUI 的丝滑体验。

