### 聊天流程与渲染管线总结（基于当前实现）

本文梳理从「发送消息」到「展示富文本回复」的完整链路：请求构造与持久化、SSE 流处理、语义分块、富文本化、代码块渲染、行抖动优化，以及项目所用框架、节流与性能优化手段。

---

## 一、发送消息与数据保存
- 入口（用户动作）
  - 点击发送/暂停按钮：`sendOrPauseButtonTapped` → `sendButtonTapped`。
- 附件处理
  - 走 `OSSUploadManager` 上传（`uploadAttachments:completion:`），回调拿到 URL 列表。
  - 以规范化块格式追加到文本末尾：
    - 形如：
      ```
      [附件链接：
      - https://...
      - https://...
      ]
      ```
  - 用于后续解析附件缩略图（`MessageContentUtils.parseAttachmentURLsFromContent:`）。
- Core Data 写入
  - 统一使用 `[[CoreDataManager sharedManager] addMessageToChat:content:isFromUser:]`。
  - 发送侧：直接拿返回对象 append 到内存数组 `self.messages`，并对表格只插入最后一行（避免 `reloadData`）。
- 输入区状态
  - 成功发送后清空输入框/附件、更新占位/按钮、收起键盘；进入等待态 `enterAwaitingState`。

---

## 二、请求模型的流程
- 思考占位
  - `simulateAIResponse` 首先插入思考行 `ThinkingNode`（`self.isAIThinking = YES`），`thinkingHintText` 根据是否含图片为“正在分析图片意图…”或“正在思考…”。
- 多模态意图分流
  - 若存在图片 URL：
    - 调用 `[[APIManager sharedManager] classifyIntentWithMessages:temperature:completion:]` 区分「生成/理解」。
    - 生成：`generateImageWithPrompt:baseImageURL:...`（DashScope），成功后以「已生成图片 + [附件链接]」形式写入。
    - 理解：将最后一条 user 消息改为 `image_url + text` 混合结构，并走文本流式（兼容 DashScope `qvq-plus` 端点）。
  - 无图片：直接调用 `streamingChatCompletionWithMessages:images:nil streamCallback:` 进入文本流式。

---

## 三、SSE 流处理与语义分块
- 流回调（SSE）
  - 回调签名：`^(NSString *partialResponse, BOOL isDone, NSError *error)`。
  - 控制器层累积：`fullResponseBuffer` 保存全量文本；`semanticParser consumeFullText:isDone:` 仅在完成一个“语义块”时返回增量块数组 `newBlocks`。
  - 首个块到达：
    - 从思考行切换为正式消息：先插入一条空 AI 消息到 Core Data，表格插入末行，再将块追加到该行（`transitionThinkingToAnswerAndAppendBlocks:`）。
  - 后续块：
    - 走 `appendBlocks:isFinal:toNode:` 增量渲染。
  - 结束：
    - 持久化 `fullResponseBuffer` 到 `currentUpdatingAIMessage`，`exitAwaitingState`，清空临时状态。

---

## 四、富文本化与数据结构
- 富文本管线（`RichMessageCellNode`）
  - 输入：控制器追加的语义块数组（纯文本片段），以 `appendSemanticBlocks:isFinal:` 形式逐块追加。
  - 内部：
    - 维护 `pendingSemanticBlockQueue`（块队列）与 `currentBlockLineTasks`（逐行任务）。
    - 对每个语义块：
      - Markdown 解析（`AIMarkdownParser`）→ `ParserResult`（文本/标题/代码块）
      - 文本转富文本：`applyMarkdownStyles`（加粗/斜体/内联代码/URL/邮箱等）
      - 固定宽度下切分为可视行（TextKit）：`lineFragmentsForAttributedString:width:`
    - 输出：一组按行的渲染任务（`text_line` 或 `code_line`）。
- 富文本数据结构
  - `ParserResult`：承载解析后的 `NSAttributedString` 与 `isCodeBlock`/`codeBlockLanguage`。
  - 渲染节点缓存：`renderNodes`（`ASTextNode`/`AICodeBlockNode`）与 `nodeCache`（去重/复用）。

---

## 五、渲染流程与代码块处理
- 逐行渲染（行级增量）
  - 调度：`scheduleNextLineTask` →（GCD 延迟）→ `performNextLineTask`。
  - 首行特殊：发送通知 `RichMessageCellNodeWillAppendFirstLine`，控制器可先移除思考行并贴底。
  - 文本行：追加 `ASTextNode`（支持 `NSAttributedString` 样式），合并到 `renderNodes`。
  - 代码行：
    - 起始行创建 `AICodeBlockNode`，并根据最长代码行像素宽设置 `fixedContentWidth`，避免渲染过程中宽度抖动。
    - 累积代码文本 `updateCodeText:`，逐行增长，保持内容高度单调递增（避免回弹）。
  - 帧级合并：通过 `CADisplayLink` 批量派发 `RichMessageCellNodeDidAppendLine`，控制器在下一帧执行粘底，降低滚动竞争。

---

## 六、行抖动与滚动优化
- 行抖动/布局抖动
  - 代码块固定内容宽度，避免因最长行变化引发反复换行。
  - 内容高度单调递增（`AICodeBlockNode` 内部只增不减）。
  - 文本富文本化在后台解析，主线程仅做节点更新与 `setNeedsLayout`，降低阻塞。
  - `performDelayedLayoutUpdate` 节流 `setNeedsLayout`（50ms 窗口 + 20ms 延迟），减少频繁布局触发。
- 自动滚动（粘底）
  - 控制器判断是否靠近底部（`isNearBottomWithTolerance`），结合用户拖动/减速/代码块横向滚动状态（`shouldPerformAutoScroll`）。
  - 粘底采用“事件驱动 + 防抖”（`requestBottomAnchorWithContext`，`kAutoScrollDebounceSeconds=20ms`）。
  - 插入/追加/键盘变化/首行渲染/内容高度显著增加（KVO `contentSize`）时按需请求粘底。
  - 用户拖动/减速中暂停 UI 更新与粘底（`pauseUIUpdates`/`resumeUIUpdates`）。

---

## 七、输入区高度与用户体验
- 输入框高度：`textViewDidChange:` 使用 `sizeThatFits:` 自适应 1～4 行，超出启用滚动。
- 发送按钮：等待态显示“暂停”，非等待态按有无文本/附件决定可用性。
- 附件缩略图：`QLThumbnailGenerator` 生成，展开/收起有动画并联动输入框顶部间距。

---

## 八、使用到的框架/库
- Texture（AsyncDisplayKit）
  - `ASDisplayNode`、`ASTextNode`、`ASStackLayoutSpec`、`ASInsetLayoutSpec` 等异步 UI 渲染与布局。
- Core Data
  - `CoreDataManager` 管理持久化，消息追加返回对象直接 append，避免重复 `fetch`。
- QuickLookThumbnailing
  - 文件缩略图生成（文档/图片）。
- Aliyun OSS / QCloud（Pods）
  - 附件上传与云存储（当前使用 `OSSUploadManager`）。
- 其他（Pods）
  - PINRemoteImage/PINCache/PINOperation（图片/缓存基础设施，间接受益）。

---

## 九、节流/防抖策略与作用
- 粘底防抖：`kAutoScrollDebounceSeconds = 0.02`
  - 统一事件入口后延迟一帧执行，合并同帧多次请求，避免与用户滚动竞争。
- 行级最小渲染间隔：`minLineRenderInterval`（默认 50ms）
  - 保证行推进节奏不过密，提升手势响应与流畅度。
- 行渲染基线：`lineRenderInterval` 与 `codeLineRenderInterval`（默认 0.41675s）
  - 统一节奏，代码行稍慢，保障横向滚动可用性。
- 布局请求节流：`performDelayedLayoutUpdate`
  - 50ms 节流 + 20ms 合并，减少 `setNeedsLayout` 冲击。

---

## 十、性能优化清单（已实施）
- 表格只插入末行，不整体 `reloadData`；`performWithoutAnimation` 避免闪烁。
- 思考行与答复行平滑过渡：先插入空消息，再追加内容，避免空白气泡与跳动。
- 代码块固定内容宽度 + 单调递增高度，显著降低抖动与回弹。
- 背景线程 Markdown 解析，主线程仅合并结果与最小布局请求。
- 用户交互期间暂停 UI 更新与自动粘底，减少“抢滚动”。
- 输入框高度基于 `sizeThatFits:`，简化计算与抖动来源。
- 消息写入直接使用插入返回对象，避免重复 `fetch` 带来的 I/O 与布局抖动。
- 缓存：文本高度缓存（`cachedHeightForText:width:`）、渲染节点缓存（`nodeCache`）。
- 缩略图异步生成，UI 端仅接收结果更新。
- 日志与多余注释清理，减少控制台与主线程干扰。

---

## 十一、关键方法导航（便于查阅）
- 控制器：
  - 发送：`sendOrPauseButtonTapped` / `sendButtonTapped`
  - 流式：`simulateAIResponse`、`appendBlocks:isFinal:toNode:`、`transitionThinkingToAnswerAndAppendBlocks:`
  - 粘底：`isNearBottomWithTolerance`、`requestBottomAnchorWithContext`、`performAutoScrollWithContext`
  - 数据：`addMessageWithText:attachments:isFromUser:completion:`、`buildMessageHistory`、`latestUserPlainText`
- 富文本：
  - 入口：`appendSemanticBlocks:isFinal:`、`updateMessageText:`
  - 行调度：`processNextSemanticBlockIfIdle`、`scheduleNextLineTask`、`performNextLineTask`
  - 代码块：`createCodeBlockNode:`（`AICodeBlockNode`）/ `updateCodeText:` / `setFixedContentWidth:`
  - 样式：`applyMarkdownStyles`、`lineFragmentsForAttributedString:width:`

> 本文档基于当前代码快照整理，若有方法命名与实现调整，请同步更新。
