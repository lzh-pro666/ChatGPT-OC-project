# 滚动效果优化说明

## 优化目标

1. **同步扩展和滚动**：避免"先扩展聊天气泡高度再滚动"的问题
2. **手势优先级**：在用户滑动时停止UI更新，保证滑动手势的流畅性

## 核心优化

### 1. 同步扩展和滚动 ✅

**问题描述**：之前的实现是先扩展聊天气泡的高度，然后再滚动到底部，导致用户看到内容先扩展再滚动的效果。

**解决方案**：使用 `performUpdatesPreservingBottom` 方法，在同一个动画块中同步执行更新和滚动。

```objc
- (void)performUpdatesPreservingBottom:(dispatch_block_t)updates {
    if (!updates) return;
    UITableView *tv = self.tableNode.view;
    BOOL nearBottom = [self isNearBottomWithTolerance:120.0];
    if (!nearBottom) {
        updates();
        return;
    }
    
    // 关键优化：同步执行更新和滚动，避免"先扩展再滚动"
    [UIView performWithoutAnimation:^{
        // 1. 执行更新
        updates();
        
        // 2. 立即布局
        [tv layoutIfNeeded];
        
        // 3. 同步滚动，保持底部对齐
        CGFloat visibleHeight = tv.bounds.size.height - tv.adjustedContentInset.bottom;
        CGFloat targetOffsetY = tv.contentSize.height - visibleHeight;
        CGFloat minOffsetY = -tv.adjustedContentInset.top; // 顶部容错
        
        if (targetOffsetY < minOffsetY) targetOffsetY = minOffsetY;
        
        // 4. 立即设置滚动位置，实现同步效果
        [tv setContentOffset:CGPointMake(tv.contentOffset.x, targetOffsetY) animated:NO];
    }];
}
```

**优化效果**：
- 聊天气泡高度扩展和滚动同步进行
- 用户看不到"先扩展再滚动"的跳跃效果
- 滚动更加流畅自然

### 2. 手势优先级控制 ✅

**问题描述**：在用户滑动TableView时，流式更新仍然在进行，可能导致滑动卡顿或冲突。

**解决方案**：添加UI更新暂停机制，在用户滑动时暂停所有UI更新。

#### 2.1 添加UI更新暂停标志
```objc
@property (nonatomic, assign) BOOL isUIUpdatePaused; // 新增：UI更新暂停标志
```

#### 2.2 在滑动手势开始时暂停UI更新
```objc
- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {
    self.userIsDragging = YES;
    self.lastContentOffsetY = scrollView.contentOffset.y;
    
    // 关键优化：用户开始滑动时，暂停所有UI更新
    [self pauseUIUpdates];
}
```

#### 2.3 在滑动手势结束时恢复UI更新
```objc
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {
    self.userIsDragging = NO;
    
    // 拖动结束后，如果接近底部，恢复自动滚动
    if (self.isNearBottom) {
        self.shouldAutoScrollToBottom = YES;
    }
    
    // 关键优化：用户停止拖动时，恢复UI更新
    if (!decelerate) {
        [self resumeUIUpdates];
    }
}

- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {
    // 减速结束后，如果接近底部，恢复自动滚动
    if (self.isNearBottom) {
        self.shouldAutoScrollToBottom = YES;
    }
    
    // 关键优化：减速结束后，恢复UI更新
    [self resumeUIUpdates];
}
```

#### 2.4 UI更新暂停和恢复方法
```objc
// 新增：暂停UI更新
- (void)pauseUIUpdates {
    self.isUIUpdatePaused = YES;
    
    // 暂停富文本节点的动画
    if (self->_currentUpdatingAINode && [self->_currentUpdatingAINode isKindOfClass:[RichMessageCellNode class]]) {
        RichMessageCellNode *richNode = (RichMessageCellNode *)self->_currentUpdatingAINode;
        if ([richNode respondsToSelector:@selector(pauseStreamingAnimation)]) {
            [richNode performSelector:@selector(pauseStreamingAnimation)];
        }
    }
}

// 新增：恢复UI更新
- (void)resumeUIUpdates {
    self.isUIUpdatePaused = NO;
    
    // 恢复富文本节点的动画
    if (self->_currentUpdatingAINode && [self->_currentUpdatingAINode isKindOfClass:[RichMessageCellNode class]]) {
        RichMessageCellNode *richNode = (RichMessageCellNode *)self->_currentUpdatingAINode;
        if ([richNode respondsToSelector:@selector(resumeStreamingAnimation)]) {
            [richNode performSelector:@selector(resumeStreamingAnimation)];
        }
    }
}
```

#### 2.5 富文本节点动画控制
```objc
// 新增：暂停流式更新动画
- (void)pauseStreamingAnimation {
    if (self.displayLink) {
        [self.displayLink setPaused:YES];
    }
}

// 新增：恢复流式更新动画
- (void)resumeStreamingAnimation {
    if (self.displayLink) {
        [self.displayLink setPaused:NO];
    }
}
```

### 3. 流式更新中的暂停检查 ✅

**实现**：在流式更新回调中添加UI更新暂停检查。

```objc
// 关键优化：检查UI更新是否被暂停
if (strongSelf.isUIUpdatePaused) {
    return; // UI更新被暂停，跳过此次更新
}
```

**效果**：
- 用户滑动时，流式更新暂停
- 滑动结束后，流式更新恢复
- 保证滑动手势的优先级和流畅性

### 4. 同步布局更新 ✅

**优化**：将 `autoStickAfterUpdate` 方法改为同步执行，避免延迟导致的滚动问题。

```objc
- (void)autoStickAfterUpdate {
    if (![self shouldPerformAutoScroll]) return;
    
    // 关键优化：使用同步更新，避免延迟导致的滚动问题
    UITableView *tv = self.tableNode.view;
    [tv layoutIfNeeded];
    
    NSIndexPath *path = [self getCurrentAINodeIndexPath];
    if (path) {
        [UIView performWithoutAnimation:^{
            [self.tableNode scrollToRowAtIndexPath:path atScrollPosition:UITableViewScrollPositionBottom animated:NO];
        }];
    } else {
        [self anchorStickToBottomPreservingOffset];
    }
}
```

## 技术要点

### 1. 同步执行
- 使用 `UIView performWithoutAnimation` 包装更新和滚动操作
- 在同一个动画块中执行布局和滚动
- 避免异步操作导致的时序问题

### 2. 手势优先级
- 监听 `scrollViewWillBeginDragging`、`scrollViewDidEndDragging`、`scrollViewDidEndDecelerating` 事件
- 在滑动开始时暂停UI更新
- 在滑动结束时恢复UI更新

### 3. 动画控制
- 通过 `CADisplayLink` 的 `setPaused` 方法控制动画
- 在富文本节点中实现动画暂停和恢复
- 确保动画状态与手势状态同步

## 测试建议

1. **测试同步滚动**：发送长消息，观察气泡扩展和滚动是否同步
2. **测试手势优先级**：在AI回复过程中滑动TableView，观察是否流畅
3. **测试动画暂停**：滑动时观察流式更新是否暂停
4. **测试动画恢复**：滑动结束后观察流式更新是否恢复

## 优化效果

- ✅ **同步扩展和滚动**：聊天气泡高度扩展和滚动同步进行
- ✅ **手势优先级**：用户滑动时UI更新暂停，保证滑动手势流畅
- ✅ **动画控制**：流式更新动画可以暂停和恢复
- ✅ **性能提升**：减少了不必要的UI更新，提高了响应性

## 总结

通过这次优化，我们实现了：
1. **同步扩展和滚动**：避免了"先扩展再滚动"的跳跃效果
2. **手势优先级控制**：在用户滑动时暂停UI更新，保证滑动手势的流畅性
3. **动画状态管理**：流式更新动画可以根据手势状态暂停和恢复

这些优化大大提升了聊天界面的用户体验，使滚动更加流畅自然，同时保证了用户手势的优先级。
