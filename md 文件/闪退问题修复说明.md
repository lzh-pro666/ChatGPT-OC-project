# 闪退问题修复说明

## 问题描述

### 闪退错误信息
```
*** Assertion failure in void ASLayoutElementSizeConstrain(CGFloat, CGFloat, CGFloat, CGFloat *, CGFloat *)(), ASDimensionInternal.mm:26
*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'maxVal must not be NaN'
```

### 问题分析
- **错误位置**: AsyncDisplayKit 的布局计算过程中
- **根本原因**: `ASDimensionMake(ASDimensionUnitFraction, 1.0)` 导致 NaN 值
- **触发条件**: 在设置文本节点的 `maxWidth` 属性时

## 问题根源

### 1. ASDimension 使用错误
```objc
// 错误的用法 - 会导致 NaN
textNode.style.maxWidth = ASDimensionMake(ASDimensionUnitFraction, 1.0);
```

### 2. 布局计算异常
- AsyncDisplayKit 在计算布局时遇到 NaN 值
- 导致断言失败，应用崩溃
- 影响所有使用该文本节点的聊天消息

## 解决方案

### 1. 移除有问题的 maxWidth 设置
```objc
// 修复前：可能导致 NaN 的设置
textNode.style.maxWidth = ASDimensionMake(ASDimensionUnitFraction, 1.0);

// 修复后：注释掉有问题的设置，让节点自然扩展
// textNode.style.maxWidth = ASDimensionMake(ASDimensionUnitFraction, 1.0);
```

### 2. 保留有效的 flex 属性设置
```objc
// 保留这些有效的设置
textNode.style.flexGrow = 1.0;
textNode.style.flexShrink = 1.0;
```

### 3. 修复范围
- **占位符节点**: 移除 `maxWidth` 设置
- **普通文本节点**: 移除 `maxWidth` 设置
- **富文本节点**: 移除 `maxWidth` 设置
- **动态创建的文本节点**: 移除 `maxWidth` 设置

## 修复详情

### 1. 占位符节点修复
```objc
if (children.count == 0) {
    ASTextNode *placeholderNode = [[ASTextNode alloc] init];
    placeholderNode.attributedText = [strongSelf attributedStringForText:(strongSelf.currentMessage ?: @"")];
    placeholderNode.maximumNumberOfLines = 0;
    // 关键修复：确保占位符节点可以显示完整文本
    placeholderNode.style.flexGrow = 1.0;
    placeholderNode.style.flexShrink = 1.0;
    // 关键修复：移除最大宽度限制，允许占位符节点扩展到所需宽度
    // 使用更安全的方法，不设置maxWidth，让节点自然扩展
    // placeholderNode.style.maxWidth = ASDimensionMakeWithFraction(1.0);
    children = @[placeholderNode];
}
```

### 2. 文本节点缓存修复
```objc
- (ASTextNode *)getOrCreateTextNodeForText:(NSString *)text {
    NSString *cacheKey = [NSString stringWithFormat:@"text_%@", text];
    ASTextNode *cachedNode = self.nodeCache[cacheKey];
    
    if (!cachedNode) {
        cachedNode = [[ASTextNode alloc] init];
        cachedNode.attributedText = [self attributedStringForText:text];
        cachedNode.maximumNumberOfLines = 0;
        // 关键修复：确保文本节点可以显示完整内容
        cachedNode.style.flexGrow = 1.0;
        cachedNode.style.flexShrink = 1.0;
        // 关键修复：移除最大宽度限制，允许文本节点扩展到所需宽度
        // 使用更安全的方法，不设置maxWidth，让节点自然扩展
        // cachedNode.style.maxWidth = ASDimensionMakeWithFraction(1.0);
        self.nodeCache[cacheKey] = cachedNode;
    }
    
    return cachedNode;
}
```

### 3. 富文本节点缓存修复
```objc
- (ASTextNode *)getOrCreateTextNodeForAttributedString:(NSAttributedString *)attributedString {
    NSString *cacheKey = [NSString stringWithFormat:@"attributed_%lu", (unsigned long)attributedString.hash];
    ASTextNode *cachedNode = self.nodeCache[cacheKey];
    
    if (!cachedNode) {
        cachedNode = [[ASTextNode alloc] init];
        cachedNode.attributedText = attributedString;
        cachedNode.maximumNumberOfLines = 0;
        // 关键修复：确保富文本节点可以显示完整内容
        cachedNode.style.flexGrow = 1.0;
        cachedNode.style.flexShrink = 1.0;
        // 关键修复：移除最大宽度限制，允许文本节点扩展到所需宽度
        // 使用更安全的方法，不设置maxWidth，让节点自然扩展
        // cachedNode.style.maxWidth = ASDimensionMakeWithFraction(1.0);
        self.nodeCache[cacheKey] = cachedNode;
    }
    
    return cachedNode;
}
```

### 4. 动态创建文本节点修复
```objc
} else {
    // 创建文本节点
    NSLog(@"RichMessageCellNode: 创建文本节点");
    ASTextNode *textNode = [self getOrCreateTextNodeForAttributedString:result.attributedString];
    // 关键修复：确保文本节点可以显示完整内容
    textNode.style.flexGrow = 1.0;
    textNode.style.flexShrink = 1.0;
    // 关键修复：移除最大宽度限制，允许文本节点扩展到所需宽度
    // 使用更安全的方法，不设置maxWidth，让节点自然扩展
    // textNode.style.maxWidth = ASDimensionMakeWithFraction(1.0);
    
    // 关键调试：输出文本节点的宽度设置和内容信息
    NSLog(@"RichMessageCellNode: 文本节点设置 - flexGrow: %.1f, flexShrink: %.1f, maxWidth: %@", 
          textNode.style.flexGrow, textNode.style.flexShrink, 
          NSStringFromASDimension(textNode.style.maxWidth));
    NSLog(@"RichMessageCellNode: 文本内容长度: %lu, 内容预览: %@", 
          (unsigned long)result.attributedString.string.length,
          [result.attributedString.string substringToIndex:MIN(100, result.attributedString.string.length)]);
    
    if (![addedNodes containsObject:textNode]) {
        [childNodes addObject:textNode];
        [addedNodes addObject:textNode];
    }
}
```

## 技术原理

### 1. Flexbox 布局原理
- **flexGrow = 1.0**: 允许节点占用所有可用空间
- **flexShrink = 1.0**: 允许节点在必要时缩小，但优先保持内容完整
- **不设置 maxWidth**: 让节点根据内容自然扩展宽度

### 2. 布局计算流程
1. **内容节点**: 设置maxWidth为屏幕宽度的75%
2. **栈布局**: 垂直排列子节点，设置flexGrow = 1.0
3. **文本节点**: 设置flexGrow = 1.0，不设置maxWidth，让节点自然扩展
4. **文本渲染**: 根据可用宽度计算换行，确保完整显示

### 3. 为什么移除 maxWidth 设置
- **避免 NaN 值**: `ASDimensionMake(ASDimensionUnitFraction, 1.0)` 可能导致 NaN
- **自然扩展**: 不设置 maxWidth 让节点根据内容自然扩展
- **布局稳定**: 避免布局计算时的异常

## 预期效果

### 1. 解决闪退问题
- 不再出现 NaN 相关的断言失败
- 应用稳定运行，不会崩溃
- 布局计算正常进行

### 2. 保持文本显示功能
- 文本仍然可以完整显示
- 自动换行正常工作
- 气泡宽度自适应内容

### 3. 性能优化
- 减少布局计算异常
- 提高应用稳定性
- 保持流畅的用户体验

## 测试要点

### 1. 稳定性测试
- 发送各种长度的消息
- 验证应用不会闪退
- 检查布局是否正常

### 2. 文本显示测试
- 发送长句子，验证完整显示
- 检查自动换行是否正确
- 验证气泡宽度是否合适

### 3. 性能测试
- 快速发送多条消息
- 滚动查看历史消息
- 验证性能是否稳定

## 总结

通过移除有问题的 `maxWidth` 设置，我们解决了：

1. **闪退问题**: 避免了 NaN 值导致的断言失败
2. **布局稳定性**: 确保布局计算正常进行
3. **功能保持**: 文本显示功能不受影响

这个修复确保了应用的稳定性，同时保持了良好的用户体验。

