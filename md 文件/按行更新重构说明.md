# 按行更新重构说明

## 重构目标
将原有的150ms时间节流机制重构为按行更新机制，实现每次网络数据都立即更新，提供更流畅的流式聊天体验。

## 主要修改内容

### 1. 常量定义修改
```objc
// 修改前：时间节流
static const NSTimeInterval kStreamRenderInterval = 0.15; // 150ms，放慢显示节奏

// 修改后：按行更新
static const NSTimeInterval kStreamRenderInterval = 0.0; // 0ms，每次网络数据都立即更新
```

### 2. 节流逻辑重构
```objc
// 修改前：基于时间的节流
NSTimeInterval now = [[NSDate date] timeIntervalSince1970];
if (now - strongSelf.lastStreamRenderTime < kStreamRenderInterval && !isDone) {
    return; // 跳过此次更新
}
strongSelf.lastStreamRenderTime = now;

// 修改后：基于内容变化的检测
if (!isDone && [partialResponse isEqualToString:strongSelf.lastDisplayedSubstring]) {
    NSLog(@"ChatDetailViewControllerV2: 内容相同，跳过此次更新");
    return; // 内容相同，跳过此次更新
}

// 记录内容变化
NSInteger oldLength = strongSelf.lastDisplayedSubstring.length;
NSInteger newLength = partialResponse.length;
NSLog(@"ChatDetailViewControllerV2: 按行更新 - 内容长度: %lu -> %lu (+%ld)", 
      (unsigned long)oldLength, (unsigned long)newLength, (long)(newLength - oldLength));

strongSelf.lastDisplayedSubstring = [partialResponse copy];
```

### 3. 属性声明修改
```objc
// 修改前：时间戳属性
@property (nonatomic, assign) NSTimeInterval lastStreamRenderTime; // 流式渲染节流时间戳

// 修改后：内容缓存属性
@property (nonatomic, copy) NSString *lastDisplayedSubstring; // 上次显示的文本内容，用于按行更新检测
```

### 4. RichMessageCellNode按行检测逻辑
新增 `detectNewLinesInText:` 方法，用于检测文本中是否有新的完整行：

```objc
- (BOOL)detectNewLinesInText:(NSString *)newText {
    if (!newText || newText.length == 0) {
        return NO;
    }
    
    // 计算新文本中的行数
    NSArray<NSString *> *newLines = [newText componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    NSArray<NSString *> *currentLines = [self.currentMessage componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    
    // 如果新文本的行数比当前文本多，说明有新行
    if (newLines.count > currentLines.count) {
        NSLog(@"RichMessageCellNode: 检测到新行，行数从 %lu 增加到 %lu", 
              (unsigned long)currentLines.count, (unsigned long)newLines.count);
        return YES;
    }
    
    // 检查是否有行内容发生变化（长度增加超过阈值）
    if (newLines.count == currentLines.count) {
        for (NSInteger i = 0; i < newLines.count; i++) {
            if (i < currentLines.count) {
                NSString *newLine = newLines[i];
                NSString *currentLine = currentLines[i];
                
                // 如果某一行长度增加超过10个字符，认为有新内容
                if (newLine.length > currentLine.length + 10) {
                    NSLog(@"RichMessageCellNode: 检测到行 %ld 内容显著增加: %lu -> %lu", 
                          (long)i, (unsigned long)currentLine.length, (unsigned long)newLine.length);
                    return YES;
                }
            }
        }
    }
    
    return NO;
}
```

### 5. 更新策略优化
```objc
// 按行更新逻辑：检测是否新增了完整的行
BOOL hasNewLine = [self detectNewLinesInText:newMessage];

if (hasNewLine) {
    NSLog(@"RichMessageCellNode: 检测到新行，执行完整解析");
    // 有新行时，重新解析以保持富文本效果
    [self forceParseMessage:newMessage];
} else {
    NSLog(@"RichMessageCellNode: 结构稳定，执行增量更新");
    // 无新行时，执行智能增量更新
    [self updateExistingNodesWithNewText:newMessage];
}
```

## 重构效果

### 优势
1. **响应更快**：不再受150ms时间限制，每次网络数据都立即更新
2. **更流畅**：按行检测确保内容变化的及时响应
3. **性能优化**：避免不必要的重复更新
4. **用户体验**：流式聊天更加自然流畅

### 更新策略
1. **新行检测**：当检测到新行时，执行完整解析
2. **增量更新**：当无新行时，执行智能增量更新
3. **内容去重**：避免相同内容的重复更新

### 调试信息
重构后增加了详细的调试日志，便于观察按行更新的效果：
- 内容长度变化记录
- 新行检测结果
- 更新策略选择

## 注意事项
1. 确保网络层数据接收的稳定性
2. 监控按行更新对性能的影响
3. 根据实际使用情况调整新行检测的阈值（当前为10个字符）
