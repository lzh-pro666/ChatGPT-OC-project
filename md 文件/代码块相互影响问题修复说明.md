# 代码块相互影响问题修复说明

## 问题描述

在富文本渲染过程中，出现了一个严重问题：**当一个代码块刷新时，会影响到其他代码块的刷新**。这导致：

1. **不必要的重新创建**：即使代码块内容没有变化，也会重新创建节点
2. **布局抖动**：所有代码块都会重新布局，造成视觉上的抖动
3. **性能下降**：频繁的节点创建和销毁影响性能
4. **用户体验差**：代码块闪烁，影响阅读体验

## 问题根因分析

### 1. 缺乏节点缓存机制
```objc
// 修复前：每次调用都创建新的代码块节点
- (ASDisplayNode *)createCodeBlockNode:(ParserResult *)result {
    // 直接创建新节点，没有缓存
    AICodeBlockNode *codeBlockNode = [[AICodeBlockNode alloc] initWithCode:codeText 
                                                                   language:language 
                                                                 isFromUser:self.isFromUser];
    return codeBlockNode;
}
```

### 2. 整体重新创建策略
```objc
// 修复前：每次更新都重新创建所有节点
for (NSInteger i = 0; i < self.parsedResults.count; i++) {
    ParserResult *result = self.parsedResults[i];
    if (result.isCodeBlock) {
        // 总是创建新的代码块节点
        ASDisplayNode *codeNode = [self createCodeBlockNode:result];
        [childNodes addObject:codeNode];
    }
}
```

### 3. 缺乏内容变化检测
没有检查现有代码块节点是否真的需要更新，导致不必要的重新创建。

## 解决方案

### 1. 实现代码块节点缓存

```objc
- (ASDisplayNode *)createCodeBlockNode:(ParserResult *)result {
    NSString *codeText = result.attributedString.string ?: @"";
    NSString *language = result.codeBlockLanguage.length > 0 ? result.codeBlockLanguage : @"code";
    
    // 关键改进：为代码块创建唯一的缓存键
    NSString *cacheKey = [NSString stringWithFormat:@"codeblock_%@_%@_%lu", 
                          language, 
                          [codeText substringToIndex:MIN(50, codeText.length)], 
                          (unsigned long)codeText.length];
    
    // 检查缓存中是否已存在相同的代码块节点
    ASDisplayNode *cachedNode = self.nodeCache[cacheKey];
    if (cachedNode) {
        NSLog(@"RichMessageCellNode: 使用缓存的代码块节点，语言: %@", language);
        return cachedNode;
    }
    
    // 创建新节点并缓存
    AICodeBlockNode *codeBlockNode = [[AICodeBlockNode alloc] initWithCode:codeText 
                                                                   language:language 
                                                                 isFromUser:self.isFromUser];
    self.nodeCache[cacheKey] = codeBlockNode;
    
    return codeBlockNode;
}
```

### 2. 智能节点重用策略

```objc
if (result.isCodeBlock) {
    // 关键改进：智能检查是否需要重新创建代码块节点
    ASDisplayNode *codeNode = nil;
    
    // 检查现有渲染节点中是否有可重用的代码块
    if (i < self.renderNodes.count) {
        ASDisplayNode *existingNode = self.renderNodes[i];
        if ([existingNode isKindOfClass:[AICodeBlockNode class]]) {
            // 使用新方法检查代码块内容是否发生变化
            if (![self isCodeBlockContentChanged:existingNode forResult:result]) {
                NSLog(@"RichMessageCellNode: 重用现有代码块节点 %ld", (long)i);
                codeNode = existingNode;
            }
        }
    }
    
    // 如果没有可重用的节点，则创建新的
    if (!codeNode) {
        NSLog(@"RichMessageCellNode: 创建新的代码块节点");
        codeNode = [self createCodeBlockNode:result];
    }
    
    [childNodes addObject:codeNode];
}
```

### 3. 内容变化检测机制

```objc
- (BOOL)isCodeBlockContentChanged:(ASDisplayNode *)existingNode forResult:(ParserResult *)result {
    if (![existingNode isKindOfClass:[AICodeBlockNode class]]) {
        return YES; // 类型不同，需要重新创建
    }
    
    AICodeBlockNode *existingCodeNode = (AICodeBlockNode *)existingNode;
    
    // 使用KVC获取属性值，避免直接访问私有属性
    NSString *existingCode = nil;
    NSString *existingLanguage = nil;
    
    @try {
        existingCode = [existingCodeNode valueForKey:@"code"];
        existingLanguage = [existingCodeNode valueForKey:@"language"];
    } @catch (NSException *exception) {
        NSLog(@"RichMessageCellNode: 无法获取代码块属性，需要重新创建: %@", exception.reason);
        return YES;
    }
    
    // 检查代码内容和语言是否相同
    BOOL contentChanged = ![existingCode isEqualToString:result.attributedString.string];
    BOOL languageChanged = ![existingLanguage isEqualToString:result.codeBlockLanguage];
    
    if (contentChanged || languageChanged) {
        NSLog(@"RichMessageCellNode: 代码块内容发生变化 - 内容: %@, 语言: %@", 
              contentChanged ? @"YES" : @"NO", 
              languageChanged ? @"YES" : @"NO");
        return YES;
    }
    
    return NO;
}
```

## 优化效果

### 1. 消除代码块相互影响
- **独立更新**：每个代码块独立检查是否需要更新
- **智能重用**：内容相同的代码块重用现有节点
- **精确更新**：只更新真正发生变化的代码块

### 2. 提升性能
- **减少节点创建**：避免不必要的节点创建和销毁
- **缓存机制**：相同内容的代码块使用缓存节点
- **布局优化**：减少不必要的布局重新计算

### 3. 改善用户体验
- **无闪烁**：代码块不再闪烁
- **稳定显示**：已显示的代码块保持稳定
- **流畅更新**：只有变化的代码块会更新

## 技术要点

### 1. 缓存键设计
```objc
NSString *cacheKey = [NSString stringWithFormat:@"codeblock_%@_%@_%lu", 
                      language,                    // 编程语言
                      [codeText substringToIndex:MIN(50, codeText.length)], // 内容前缀
                      (unsigned long)codeText.length];                       // 内容长度
```

### 2. 节点类型检查
```objc
if ([existingNode isKindOfClass:[AICodeBlockNode class]]) {
    // 确保是代码块节点类型
}
```

### 3. 安全属性访问
```objc
@try {
    existingCode = [existingCodeNode valueForKey:@"code"];
    existingLanguage = [existingCodeNode valueForKey:@"language"];
} @catch (NSException *exception) {
    // 异常处理，确保程序稳定性
    return YES;
}
```

## 总结

通过实现代码块节点缓存、智能重用策略和内容变化检测，我们成功解决了代码块相互影响的问题：

1. **缓存机制**：避免重复创建相同的代码块节点
2. **智能重用**：检查现有节点是否可以重用
3. **精确更新**：只更新真正发生变化的代码块
4. **性能提升**：减少不必要的节点创建和布局计算
5. **用户体验**：消除代码块闪烁，提供稳定的显示效果

现在每个代码块都能独立更新，不会相互影响，提供了更好的用户体验和性能表现。

