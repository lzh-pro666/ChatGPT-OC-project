# 富文本逐行显示重构说明

## 重构目标
将原有的"先显示纯文本，最后转换为富文本"的机制重构为"从一开始就使用富文本格式，并且代码块内的文本也能逐行显示"的实时富文本逐行显示效果。

## 重构前的问题分析

### 从控制台数据观察到的现象
```
RichMessageCellNode: 进入流式模式，当前长度: 0 -> 26
RichMessageCellNode: 按行更新模式，新消息长度: 27
RichMessageCellNode: 结构稳定，执行增量更新
...
RichMessageCellNode: 流式更新完成，触发最终渲染
RichMessageCellNode: forceParseMessage called with: [完整的消息内容]
```

**问题**：
1. 流式更新过程中显示的是纯文本
2. 只有到最后才转换为富文本格式
3. 代码块内的文本无法逐行显示
4. 用户体验不够流畅

## 重构后的解决方案

### 1. 强制实时富文本解析
```objc
- (void)updateTextContentDirectly:(NSString *)newMessage {
    // 富文本逐行显示：每次都进行富文本解析，确保实时显示富文本效果
    NSLog(@"RichMessageCellNode: 执行富文本实时解析");
    [self forceParseMessage:newMessage];
}
```

**优势**：
- 每次网络数据更新都立即转换为富文本
- 代码块、标题、段落等格式实时显示
- 用户体验更加流畅

### 2. 优化富文本解析性能
```objc
- (void)forceParseMessage:(NSString *)message {
    // 富文本实时解析：使用 AIMarkdownParser 进行完整解析
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        // 后台线程：Markdown解析和富文本处理（高优先级）
        NSArray<AIMarkdownBlock *> *markdownBlocks = [strongSelf.markdownParser parse:(message ?: @"")];
        // ... 解析逻辑
    });
}
```

**优化点**：
- 使用高优先级队列，确保解析速度
- 后台线程解析，不阻塞UI
- 主线程更新，确保UI响应性

### 3. 实时布局更新
```objc
- (void)immediateLayoutUpdate {
    // 富文本实时更新：立即布局，不进行节流
    if ([NSThread isMainThread]) {
        [UIView performWithoutAnimation:^{
            [self setNeedsLayout];
            [self layoutIfNeeded];
        }];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView performWithoutAnimation:^{
                [self setNeedsLayout];
                [self layoutIfNeeded];
            }];
        });
    }
}
```

**特点**：
- 无节流机制，确保实时显示
- 使用无动画更新，避免视觉跳跃
- 立即布局，响应更快

### 4. 降低新行检测阈值
```objc
- (BOOL)detectNewLinesInText:(NSString *)newText {
    // 如果某一行长度增加超过5个字符，认为有新内容（降低阈值，提高响应性）
    if (newLine.length > currentLine.length + 5) {
        return YES;
    }
}
```

**改进**：
- 从10个字符降低到5个字符
- 提高响应性，更早触发富文本更新
- 确保代码块内的文本也能及时显示

## 重构后的效果

### 预期行为
1. **实时富文本显示**：每次网络数据更新都立即显示富文本格式
2. **代码块逐行显示**：代码块内的文本也能逐行显示，保持语法高亮
3. **标题实时更新**：标题格式在输入过程中实时显示
4. **段落实时渲染**：段落格式和样式实时应用

### 控制台日志变化
```
// 重构前
RichMessageCellNode: 按行更新模式，新消息长度: 27
RichMessageCellNode: 结构稳定，执行增量更新

// 重构后
RichMessageCellNode: 富文本逐行更新模式，新消息长度: 27
RichMessageCellNode: 执行富文本实时解析
RichMessageCellNode: 富文本实时解析完成，共 X 个结果
RichMessageCellNode: 富文本内容变化，实时更新渲染节点
RichMessageCellNode: 富文本实时布局更新完成
```

## 性能考虑

### 优化策略
1. **高优先级解析**：使用 `DISPATCH_QUEUE_PRIORITY_HIGH` 确保解析速度
2. **后台线程处理**：Markdown解析在后台线程进行，不阻塞UI
3. **智能缓存**：保留节点缓存机制，避免重复创建
4. **无动画更新**：使用 `performWithoutAnimation` 避免视觉跳跃

### 潜在影响
1. **CPU使用率**：每次更新都进行富文本解析，CPU使用率可能增加
2. **内存使用**：实时创建富文本节点，内存使用可能增加
3. **电池消耗**：频繁的解析和渲染可能增加电池消耗

### 监控建议
1. 观察CPU使用率变化
2. 监控内存使用情况
3. 测试电池消耗影响
4. 根据实际使用情况调整解析频率

## 测试验证

### 测试场景
1. **普通文本流式更新**：验证段落格式实时显示
2. **代码块流式更新**：验证代码块逐行显示和语法高亮
3. **标题流式更新**：验证标题格式实时应用
4. **混合内容更新**：验证多种格式混合时的显示效果

### 验证指标
1. **响应速度**：富文本格式是否实时显示
2. **显示质量**：富文本格式是否正确
3. **性能表现**：是否影响整体性能
4. **用户体验**：是否更加流畅自然

## 注意事项

### 1. 性能监控
- 密切关注CPU和内存使用情况
- 如果性能影响过大，可以考虑增加节流机制

### 2. 兼容性
- 确保与现有的富文本解析逻辑兼容
- 保持代码块、标题等特殊格式的正确显示

### 3. 用户体验
- 富文本逐行显示应该比纯文本逐行显示更流畅
- 如果出现卡顿，需要进一步优化

### 4. 调试支持
- 增加了详细的调试日志
- 便于观察富文本逐行显示的效果 