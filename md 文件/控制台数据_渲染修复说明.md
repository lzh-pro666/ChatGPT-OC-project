### 代码块在“字符串插值”后渲染错误的原因与修复说明

以下问题复现于日志文件 `控制台数据.md` 的“字符串插值”章节附近。

- 现象摘要：
  - 在“### 字符串插值”标题之后，服务端输出了一个独立行的 `swift` 文本，随后是多行代码与普通段落交错。
  - 部分围栏代码块（``` 开闭）在块内混入了 Markdown 标题（如 `### 数组和字典`），被当作代码渲染并生成了 `plaintext` 代码节点，导致“标题被渲染成代码”。
  - 在逐行渲染期间，文本占位与代码块节点可能并存，使视觉上更像是“代码块渲染错误/混合”。

- 根因分析：
  1) 语义块切分：`SemanticBlockParser` 按围栏完整性分块是正确的；但紧跟标题出现的带有围栏的内容里若只包含 Markdown 结构（如 `### 标题`）时，`AIMarkdownParser` 会把整个围栏当作代码块（语言为空→plaintext），从而将标题误渲染为代码。
  2) 流式 UI：`RichMessageCellNode` 在 `children.count == 0` 时使用占位文本节点，即使处于流式模式也会展示，和逐行渲染的真实节点并存，造成“混渲”观感。
  3) 线程顺序：`buildLineTasksForBlockText:` 的 completion 在后台线程里直接修改了渲染状态与队列，存在小概率竞态，可能导致行任务推进时序不稳定（偶发 UI 异常）。

- 修复与优化：
  1) 降级启发式（关键修复）
     - 文件：`ChatGPT-OC-Clone/Model/AIMarkdownParser.m`
     - 变更：新增 `isLikelyNonCodeBlock(content, language)` 启发式。当围栏块语言未显式指定（或为 plaintext）且内部仅包含 Markdown 结构（如单行/多行全是 `#` 标题），则将该围栏内容降级为“非代码块”（拆成标题/段落），而不是生成 `CodeBlock`。
     - 影响：避免把 `### 数组和字典` 这类结构包裹在 ``` 内时被误判为代码，彻底修正“标题被当作代码块渲染”的问题。

  2) 占位文本仅在非流式显示（避免混渲）
     - 文件：`ChatGPT-OC-Clone/View/RichMessageCellNode.m`
     - 变更：在 `layoutSpecBlock` 中将占位文本条件改为 `children.count == 0 && currentMessage.length > 0 && !isStreamingMode`。
     - 影响：流式期间不再显示占位文本，避免与逐行生成的真实文本/代码节点并存，提升视觉一致性。

  3) 主线程合并行任务（消除竞态）
     - 文件：`ChatGPT-OC-Clone/View/RichMessageCellNode.m`
     - 变更：`buildLineTasksForBlockText:` 的 completion 结果先跳回主线程，再更新 `currentBlockLineTasks` 等状态并调用 `scheduleNextLineTask`。
     - 影响：消除跨线程状态修改导致的偶发顺序问题，保证逐行渲染推进时序稳定。

- 为什么修复有效：
  - 日志显示在“字符串插值”后出现的 ``` 包裹了 `### 数组和字典`，此前会被解析成 `plaintext` 代码块。引入降级启发式后，该围栏内仅含 Markdown 结构时不再产出代码块，而是产出正确的标题/段落，根本消除了“错误的代码块”。
  - 关闭流式占位后，屏幕上只会出现真实的逐行渲染节点，避免“同一段内容既以文本又以代码形式显示”的错觉。
  - 回到主线程后再推进任务，避免罕见条件下代码块行与普通行顺序错乱，杜绝“间或消失/闪断”的渲染异常。

- 相关修改位置（关键片段）

```AIMarkdownParser.m
// 新增：isLikelyNonCodeBlock 启发式，结束围栏与收尾处均应用，必要时将围栏内容降级为标题/段落
```

```RichMessageCellNode.m
// layoutSpecBlock 内：
// if (children.count == 0 && currentMessage.length > 0 && !isStreamingMode) { ... }

// buildLineTasksForBlockText completion 内：
// 若非主线程，dispatch_async 回主线程后再更新状态与调用 scheduleNextLineTask
```

- 建议后续观察点：
  - 若上游服务偶发返回乱序/回退的“累积文本”，`SemanticBlockParser` 会 reset 并可能重复发射块，UI 会重复追加。可在控制器层面检测并去重（例如对语义块做指纹去重）。
  - 如需进一步减少误判，可在启发式中加入更多语言关键字/标记，或在服务端侧约束输出结构（标题不应放在 ``` 内）。

- 结论
  - 以上三处修复在不改变现有显示样式前提下，提升了“字符串插值”章节后的语义块传输稳定性，并修正了围栏包裹 Markdown 结构导致的代码块误渲染问题。 