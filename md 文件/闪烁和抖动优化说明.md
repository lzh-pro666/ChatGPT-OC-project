# 闪烁和抖动优化说明

## 🔍 问题分析

根据控制台数据分析，发现了导致闪烁和抖动的根本原因：

### 1. **过度频繁的布局更新**
```
RichMessageCellNode: 高度变化显著 (19.1 -> 9199.5)，需要更新布局
RichMessageCellNode: 更新渲染节点
```
- 每次增量更新都触发布局更新
- 高度变化巨大，从19.1到9199.5像素
- 每次更新都调用 `setNeedsLayout`

### 2. **增量更新逻辑错误**
```
RichMessageCellNode: 执行增量更新，不重新解析
RichMessageCellNode: 已更新渲染节点的文本内容
```
- 每次都在更新最后一个文本节点
- 导致已显示的文本不断被替换
- 没有固定已完成的文本

### 3. **布局重复计算**
- 每次高度变化都重新计算布局
- 没有缓存已完成的布局
- 缺乏布局稳定性检查

## 🛠️ 优化方案

### 1. **智能增量更新系统**

#### 核心思想
- **固定已显示文本**：已完成的文本不再被修改
- **只更新正在输入**：只更新正在输入的文本部分
- **减少布局更新**：避免不必要的布局重新计算

#### 实现逻辑
```objc
// 检查是否是追加内容
if ([newText hasPrefix:currentContent]) {
    NSString *appendedText = [newText substringFromIndex:currentContent.length];
    
    // 只有当追加内容超过一定长度时才更新，避免频繁更新
    if (appendedText.length > 5) {
        // 执行智能更新
    }
}
```

### 2. **布局缓存机制**

#### 布局稳定性检查
```objc
- (BOOL)isLayoutStableForText:(NSString *)text {
    // 检查是否包含可能导致布局变化的元素
    if ([text containsString:@"```"]) return NO;  // 代码块
    if ([text containsString:@"###"]) return NO;  // 标题
    if ([text containsString:@"- "]) return NO;   // 列表
    return YES;
}
```

#### 布局缓存
```objc
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSValue *> *layoutCache;
@property (nonatomic, assign) BOOL isLayoutStable;
```

### 3. **智能布局更新**

#### 更新策略
- **高度阈值**：提高到15像素，减少微小变化触发的更新
- **稳定性检查**：只有布局稳定时才更新
- **线程安全**：确保所有UI操作在主线程执行

```objc
if (heightDifference > 15.0 && isStable) {
    // 高度变化显著且布局稳定，更新布局
    [self smartLayoutUpdate];
} else if (heightDifference > 15.0 && !isStable) {
    // 高度变化显著但布局不稳定，标记为不稳定
    self.isLayoutStable = NO;
} else {
    // 高度变化微小，只更新文本内容，不触发布局
}
```

## 📋 优化效果

### 1. **减少布局更新**
- ✅ 提高高度变化阈值到15像素
- ✅ 只在布局稳定时更新
- ✅ 避免微小变化触发的更新

### 2. **固定已显示文本**
- ✅ 已完成的文本不再被修改
- ✅ 只更新正在输入的文本
- ✅ 减少文本"扯动"现象

### 3. **智能缓存机制**
- ✅ 布局稳定性缓存
- ✅ 高度变化缓存
- ✅ 减少重复计算

## 🔧 技术细节

### 1. **增量更新优化**
```objc
// 智能更新：只更新正在输入的文本，固定已显示的文本
if (newText.length > currentContent.length) {
    if ([newText hasPrefix:currentContent]) {
        NSString *appendedText = [newText substringFromIndex:currentContent.length];
        if (appendedText.length > 5) {
            // 执行更新
        }
    }
}
```

### 2. **布局稳定性检查**
```objc
- (BOOL)isLayoutStableForText:(NSString *)text {
    // 检查代码块、标题、列表等可能导致布局变化的元素
    if ([text containsString:@"```"]) return NO;
    if ([text containsString:@"###"]) return NO;
    if ([text containsString:@"- "]) return NO;
    return YES;
}
```

### 3. **智能布局更新**
```objc
- (void)smartLayoutUpdate {
    if (!self.isLayoutStable) {
        NSLog(@"布局不稳定，跳过更新");
        return;
    }
    
    // 确保在主线程执行
    if ([NSThread isMainThread]) {
        [UIView performWithoutAnimation:^{
            [self setNeedsLayout];
        }];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView performWithoutAnimation:^{
                [self setNeedsLayout];
            }];
        });
    }
}
```

## 🧪 测试验证

### 1. **功能测试**
- 发送包含代码块的消息
- 验证流式打字机效果
- 检查文字是否还有抖动

### 2. **性能测试**
- 监控布局更新频率
- 检查内存使用
- 验证响应速度

### 3. **稳定性测试**
- 快速发送多条消息
- 在打字过程中切换应用
- 验证应用不会崩溃

## 📝 关键改进

### 1. **减少更新频率**
- 追加内容长度阈值：5字符
- 高度变化阈值：15像素
- 布局稳定性检查

### 2. **固定已完成内容**
- 已显示的文本不再被修改
- 只更新正在输入的文本
- 避免文本"扯动"

### 3. **智能缓存**
- 布局稳定性缓存
- 高度变化缓存
- 减少重复计算

## 🚀 预期效果

### 1. **用户体验**
- ✅ 消除文字抖动和闪烁
- ✅ 流式打字机效果更流畅
- ✅ 已显示文本保持稳定

### 2. **性能提升**
- ✅ 减少布局计算次数
- ✅ 降低CPU占用
- ✅ 提高响应速度

### 3. **稳定性增强**
- ✅ 避免重复布局
- ✅ 减少内存使用
- ✅ 提高应用稳定性

## 📊 监控指标

### 1. **布局更新频率**
- 监控 `setNeedsLayout` 调用次数
- 检查高度变化频率
- 验证布局稳定性

### 2. **性能指标**
- CPU使用率
- 内存占用
- 响应时间

### 3. **用户体验**
- 文字抖动频率
- 闪烁现象
- 流畅度评分


