### 消息从“发送”到“渲染”的全链路流程（ChatDetailViewControllerV2 + RichMessageCellNode）

本文梳理 iOS ChatGPT 克隆项目中，从用户点击发送到消息在 UI 上富文本渲染的完整链路：涉及入口事件、数据入库、列表插入、AI 流式回调、语义分块增量渲染、粘底策略、错误与收尾等。主角组件：`ChatDetailViewControllerV2`、`RichMessageCellNode`，并配合 `APIManager`、`CoreDataManager`、`SemanticBlockParser`、`OSSUploadManager` 等。

---

## 关键参与者
- **ChatDetailViewControllerV2**: 消息编排中枢（输入+附件→发送→持久化→列表插入→AI流式→UI粘底）。
- **ASTableNode (Texture)**: 高性能消息列表，支持异步布局与插入批处理。
- **CoreDataManager**: 消息/会话的持久化与查询。
- **APIManager**: 与模型进行流式 SSE 通信、图片意图分类/生成等网络层。
- **SemanticBlockParser**: 将「全量流式文本」解析为语义块（段落/标题/列表/代码块）以按块增量渲染。
- **RichMessageCellNode**: 富文本消息气泡节点，支持 Markdown、代码块与“逐行渐显”呈现。
- **ThinkingNode**: AI 思考占位行（“正在思考…”）。
- **OSSUploadManager**: 附件上传，得到 URL 后并入消息。

---

## 时序流程详解

### 1) 发送入口与输入收集
- 用户点击底部发送按钮：
  - `sendOrPauseButtonTapped` → 若未处于等待态，转入 `sendButtonTapped`。
  - 判空与防抖：无文本且无附件直接返回；发送期间禁用按钮，避免重复点击。

```12:18:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)sendOrPauseButtonTapped {
    if (!self.sendButton.enabled) { return; }
    if (self.isAwaitingResponse) { [self handlePauseTapped]; return; }
    [self sendButtonTapped];
}
```

```612:620:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)sendButtonTapped {
    if (self.inputTextView.text.length == 0 && self.selectedAttachments.count == 0) return;
    self.sendButton.enabled = NO;
    NSString *userMessage = [self.inputTextView.text copy];
    NSArray *attachments = [self.selectedAttachments copy];
    ...
}
```

### 2) 附件上传与消息规范化
- 若存在附件：通过 `OSSUploadManager` 上传，获得 URL 列表后，将 `附件链接` 规范化追加到文本，并记录本轮 `pendingImageURLs`（供后续“生成/理解”分支使用）。随后清空输入框/附件区并继续发送。

```620:659:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
[[OSSUploadManager sharedManager] uploadAttachments:attachments completion:^(NSArray<NSURL *> *uploadedURLs) {
    NSMutableString *finalMessage = [NSMutableString stringWithString:userMessage ?: @""];
    ... // 追加“[附件链接：\n- url\n]”
    self.pendingImageURLs = uploadedURLs;
    self.inputTextView.text = @"";
    [self.selectedAttachments removeAllObjects];
    [self updateAttachmentsDisplay];
    [self textViewDidChange:self.inputTextView];
    [self.inputTextView resignFirstResponder];
    [self addMessageWithText:finalMessage attachments:@[] isFromUser:YES completion:^{
        [self enterAwaitingState];
        [self simulateAIResponse];
    }];
}];
```

### 3) 数据入库与列表插入（用户消息）
- 通过 `CoreDataManager addMessageToChat` 持久化；本地数据源尾部推入；仅插入一行，避免整表刷新；无动画滚动到底部，保证“粘底”。

```1384:1414:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)addMessageWithText:(NSString *)text attachments:(NSArray *)attachments isFromUser:(BOOL)isFromUser completion:(void (^)(void))completion {
    NSManagedObject *inserted = [[CoreDataManager sharedManager] addMessageToChat:self.chat content:text isFromUser:isFromUser];
    ...
    [self.tableNode performBatchUpdates:^{
        [self.tableNode insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationNone];
    } completion:^(BOOL finished) {
        if (finished) {
            [self.tableNode scrollToRowAtIndexPath:newIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:NO];
            if (completion) { completion(); }
        }
    }];
}
```

### 4) 进入等待态与“思考”占位
- 切换按钮为“暂停”样式（`enterAwaitingState` → `updateSendButtonState`）。
- 构建“思考”行：`simulateAIResponse` 置位 `isAIThinking=YES`，插入 `ThinkingNode`，并根据是否有图片设置提示文案。

```1092:1120:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)simulateAIResponse {
    ...
    self.isAIThinking = YES;
    self.thinkingHintText = (self.pendingImageURLs.count > 0) ? @"正在分析图片意图…" : @"正在思考…";
    [self enterAwaitingState];
    NSIndexPath *thinkingIndexPath = [NSIndexPath indexPathForRow:self.messages.count inSection:0];
    [self.tableNode performBatchUpdates:^{
        [self.tableNode insertRowsAtIndexPaths:@[thinkingIndexPath] withRowAnimation:UITableViewRowAnimationNone];
    } completion:...];
}
```

### 5) 历史构建与“生成/理解”分支（可选）
- `buildMessageHistory` 注入系统提示与历史消息。
- 若存在 `pendingImageURLs`：调用 `APIManager classifyIntentWithMessages` 判定“生成”或“理解”。
  - 生成：`APIManager generateImageWithPrompt` 取结果图 URL，移除思考行并插入 AI 文本提示或结果。
  - 理解：回落到文本流式对话。

### 6) 发起文本流式请求（SSE）
- 纯文本或“理解”场景：`APIManager streamingChatCompletionWithMessages:... streamCallback:`。
- SSE 回调按节流在主线程触发；控制器在后台 `semanticQueue` 将“全量文本”交给 `SemanticBlockParser` 切成“语义块”，再切回主线程进行 UI 应用。

```1229:1247:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
strongSelf.currentStreamingTask = [[APIManager sharedManager] streamingChatCompletionWithMessages:messages model:@"qvq-plus" baseURL:dashscopeBaseURL apiKey:dashscopeKey streamCallback:^(NSString *partialResponse, BOOL isDone, NSError *error) {
    dispatch_async(sself.semanticQueue, ^{
        if (error) { ... }
        [sself.fullResponseBuffer setString:(partialResponse ?: @"")];
        if (sself.isUIUpdatePaused && !isDone) { return; }
        NSArray<NSString *> *preparedBlocks = [sself.semanticParser consumeFullText:(partialResponse ?: @"") isDone:isDone];
        if (preparedBlocks.count == 0) { return; }
        dispatch_async(dispatch_get_main_queue(), ^{
            [sself ui_applyPreparedBlocks:preparedBlocks isDone:isDone thinkingIndexPath:thinkingIndexPath];
            if (isDone) { ... 持久化收尾 ... }
        });
    });
}];
```

> API 层（节流+SSE 解析要点）
```384:452:ChatGPT-OC-Clone/Tool/APIManager.m
- (NSURLSessionDataTask *)streamingChatCompletionWithMessages:(NSArray *)messages streamCallback:(StreamingResponseBlock)callback {
    ... // 设置 headers、body、Accept: text/event-stream
    // 内部使用 stateAccessQueue 和定时器进行 UI 回调节流，每 ~16ms 刷新一次累计文本
}
```

### 7) 首包切换、节点绑定与块应用
- 首包到达时：若仍处于思考态，则先在 CoreData 插入一条“空 AI 消息”，并插入到列表尾部；随后把“思考行”切换为“答案行”。
- 控制器维护 `_currentUpdatingAINode` 指向当前 AI 的 `RichMessageCellNode`，用于持续增量追加。

```1308:1339:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)ui_applyPreparedBlocks:(NSArray<NSString *> *)blocks isDone:(BOOL)isDone thinkingIndexPath:(NSIndexPath *)thinkingIndexPath {
    if (self.isAIThinking) {
        self.currentUpdatingAIMessage = [[CoreDataManager sharedManager] addMessageToChat:self.chat content:@"" isFromUser:NO];
        [self fetchMessages];
        NSIndexPath *finalMessagePath = [NSIndexPath indexPathForRow:self.messages.count - 1 inSection:0];
        ...
        [self transitionThinkingToAnswerAndAppendBlocks:blocks isFinal:isDone toNode:node];
    } else {
        [self appendBlocks:blocks isFinal:isDone toNode:self->_currentUpdatingAINode];
    }
}
```

```1899:1915:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)appendBlocks:(NSArray<NSString *> *)blocks isFinal:(BOOL)isDone toNode:(id)node {
    if ([node respondsToSelector:@selector(appendSemanticBlocks:isFinal:)]) {
        [node appendSemanticBlocks:blocks isFinal:isDone];
        [node setNeedsLayout];
        [self anchorScrollToBottomIfNeeded];
    } else if ([node respondsToSelector:@selector(updateMessageText:)]) {
        NSString *accumulated = [self.semanticRenderedBuffer copy];
        [node updateMessageText:accumulated];
    }
}
```

### 8) RichMessageCellNode 的“逐行渐显”渲染
- 入口：`appendSemanticBlocks:isFinal:` 将语义块加入待处理队列；后台用 `AIMarkdownParser` 将块切分为可视行任务（文本/代码行），主线程按节奏推进，逐行创建/追加 `ASTextNode` 或 `AICodeBlockNode`。
- 首行追加前发送通知 `RichMessageCellNodeWillAppendFirstLine`，控制器先移除思考行后再贴底，避免“空白气泡”。每行完成后通过 `RichMessageCellNodeDidAppendLine` 合并粘底。

```1127:1154:ChatGPT-OC-Clone/View/RichMessageCellNode.m
- (void)appendSemanticBlocks:(NSArray<NSString *> *)blocks isFinal:(BOOL)isFinal {
    self.isStreamingMode = YES;
    ... // 追加到 pendingSemanticBlockQueue，更新 currentMessage
    [self processNextSemanticBlockIfIdle];
}
```

```1356:1371:ChatGPT-OC-Clone/View/RichMessageCellNode.m
- (void)performNextLineTask {
    if (self.currentBlockRenderedLineIndex == 0) {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"RichMessageCellNodeWillAppendFirstLine" object:self];
        if (self.startHiddenUntilFirstLine) { self.bubbleNode.hidden = NO; self.contentNode.hidden = NO; [self immediateLayoutUpdate]; }
    }
    ... // 逐行生成文本或代码节点
    [self scheduleBatchedLineNotification]; // 下一帧合并发送 DidAppendLine
}
```

### 9) 粘底策略与交互暂停
- 控制器监听富文本节点逐行通知：
  - `handleRichMessageWillAppendFirstLine`、`handleRichMessageAppendLine` → `requestBottomAnchorWithContext:`，在用户未主动上滑时保持“粘底”。
- 遇到代码块横向滚动/用户减速滚动等交互时，控制器会暂停 UI 更新与自动滚动；交互结束后恢复（并调用节点的 `pauseStreamingAnimation`/`resumeStreamingAnimation`）。

```1868:1875:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (void)handleRichMessageWillAppendFirstLine:(NSNotification *)note {
    [self requestBottomAnchorWithContext:@"handleRichMessageWillAppendFirstLine"]; 
}
```

### 10) 持久化、错误与收尾
- 每次首包建立后会创建空 AI 消息并随着流式增量更新；在 `isDone` 或页面切换/消失时写回 `fullResponseBuffer` 并 `saveContext`，保证crash后也能恢复已渲染内容。
- 错误处理：
  - 取消：移除思考行静默结束。
  - 首包错误：移除思考行并插入错误气泡；退出等待态。
  - 后续错误：在已渲染尾部追加错误提示，并持久化。
- 收尾：`exitAwaitingState` 恢复发送按钮；`RichMessageCellNode completeStreamingUpdate` 做最终解析与无动画布局，确保富文本样式完整呈现。

---

## 数据流向（文字示意）
- 输入区（`UITextView` + 附件）
  → 附件上传（`OSSUploadManager`，回主线程清空选择）
  → 用户消息持久化（`CoreDataManager addMessageToChat`）
  → 列表尾插（`ASTableNode performBatchUpdates`）
  → 进入等待态 + 思考行（`isAIThinking`/`ThinkingNode`）
  → 文本流式（`APIManager` SSE 回调）
  → 语义分块（`SemanticBlockParser.consumeFullText`）
  → 首包：插入空 AI 消息 + 绑定 `_currentUpdatingAINode`
  → 逐行渲染（`RichMessageCellNode appendSemanticBlocks` → `performNextLineTask`）
  → 粘底（通知 → 控制器锚定到底部）
  → 完结/错误（持久化、收尾、恢复按钮）。

---

## 列表节点构建（用户/AI）
- 列表数据源：`nodeBlockForRowAtIndexPath:` 统一创建 `RichMessageCellNode`，并在当前 AI 行时记录 `_currentUpdatingAINode` 以供增量更新。

```767:809:ChatGPT-OC-Clone/Controller/ChatDetailViewControllerV2.m
- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath {
    if (self.isAIThinking && indexPath.row == self.messages.count) { ... return ThinkingNode; }
    NSString *message = [self messageAtIndexPath:indexPath];
    BOOL isFromUser = [self isMessageFromUserAtIndexPath:indexPath];
    NSArray *attachments = [self attachmentsAtIndexPath:indexPath];
    return ^ASCellNode *{
        RichMessageCellNode *rich = [[RichMessageCellNode alloc] initWithMessage:message isFromUser:isFromUser];
        if (attachments.count > 0) { [rich setAttachments:attachments]; }
        if (!isFromUser && [strongSelf isIndexPathCurrentAINode:indexPath]) {
            strongSelf->_currentUpdatingAINode = (id)rich;
        }
        return rich;
    };
}
```

---

## 用到的关键技术
- **Texture/AsyncDisplayKit**：`ASTableNode` 异步布局、`ASCellNodeBlock` 延迟创建、批量插入无动画减少抖动。
- **SSE 流式**：`APIManager` 将服务端 `data:` 流解析与节流，回调主线程，提升更新平滑性。
- **语义分块**：`SemanticBlockParser` 按 Markdown 语义边界（标题/列表/段落/围栏代码）切块，避免“半行/半句”抖动。
- **逐行渐显**：`RichMessageCellNode` 将语义块切为可视行，按统一节奏追加行节点，配合通知保证粘底。
- **多模态**：附件上传（`OSSUploadManager`）、图片“生成/理解”分类与生成分支（`APIManager`）。
- **持久化**：`CoreDataManager` 每步写入与收尾保存，支持中断恢复。
- **交互友好**：代码块横向滚动时暂停 UI 自动更新；用户上滑时停止粘底，防止“抢滚动”。

---

## 快速索引（方法→文件）
- 发送入口：`sendOrPauseButtonTapped` / `sendButtonTapped` → `ChatDetailViewControllerV2.m`
- 数据入库/插入：`addMessageWithText:attachments:isFromUser:completion:` → `ChatDetailViewControllerV2.m`
- 思考与流式：`simulateAIResponse` / `ui_applyPreparedBlocks:isDone:` / `appendBlocks:isFinal:toNode:` → `ChatDetailViewControllerV2.m`
- 节点渲染：`appendSemanticBlocks:isFinal:` / `performNextLineTask` → `RichMessageCellNode.m`
- 持久化：`addMessageToChat` / `fetchMessagesForChat` / `saveContext` → `CoreDataManager.m`
- 流式网络：`streamingChatCompletionWithMessages...` / `classifyIntentWithMessages` / `generateImageWithPrompt` → `APIManager.m`
- 语义分块：`consumeFullText:isDone:` → `SemanticBlockParser.m`

---

以上即可覆盖“发送→渲染”的核心路径与技术点，结合引用代码定位，可快速在项目中查阅与调试。
