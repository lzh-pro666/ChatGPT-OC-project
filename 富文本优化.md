好的 👍，我把前面两次的分析整理成一个**技术总结**，方便你整体把握：

---

## iOS AI 聊天 App 流式回复的技术总结

### 1. 两种渲染方式

* **逐 token 追加**

  * 每收到一个 token 就更新 UI。
  * 缺点：频繁触发富文本排版，CPU 占用高，容易掉帧。
  * 优点：实现简单，实时感强。

* **逐行追加（推荐）**

  * SSE 收到内容后，先在后台做 **完整富文本排版**，缓存每行的 range。
  * 前台只在「整行准备好」时更新一次 UI，并配合遮罩做 reveal 动画。
  * 优点：

    * UI 更新频率低，性能好。
    * 遮罩动画更自然。
    * 不会出现逐 token 抖动、重排。

---

### 2. 行级缓存与分行实现

* 不能简单依赖 **插入特殊符号** 来分行，因为：

  * 容易破坏 `NSAttributedString` 的属性（粗体、链接、代码块）。
  * 字体排版差异可能导致后台和前台断行不一致。
* 正确做法：

  * 用 CoreText (`CTFramesetter` + `CTLineGetStringRange`) 或 TextKit 直接计算每行 range。
  * 缓存成 `NSArray<NSRange>`，对应每一行文本。
  * 前台显示时，只要依次取 substring → 拼接 → 渐显。

---

### 3. 动画效果（模拟 ChatGPT / 豆包的丝滑流式感）

* 使用 **遮罩 (mask layer)** 做从左到右 reveal，而不是逐字修改透明度。
* Reveal 时机：

  1. SSE 收到第一行 → 隐藏「思考中」视图。
  2. 每行准备好 → 使用 mask 动画显示。
  3. 一行完成后 → 继续下一行。

---

### 4. 性能优化点

* **后台排版**：富文本拼接、断行计算在子线程完成。
* **前台只负责动画**：显示时只是从缓存拿 substring，不再计算排版。
* **一致性保证**：气泡宽度在后台计算和前台显示保持一致，否则会错行。
* **部分行渲染**：SSE 还没结束时，可以先显示已完整的行，半行 token 暂存。

---

✅ **结论**

* 行级流式渲染 + 遮罩 reveal 是比逐 token 渲染更高效、更丝滑的方案。
* 关键在于：**后台用 CoreText/TextKit 切行 → 前台按行播放 → 遮罩动画 reveal**。
* 这种实现方式能兼顾性能、流畅度、富文本一致性，接近 ChatGPT / 豆包 / DeepSeek 的交互体验。

---

我现在有一个方案，将流式回复的sse 结果传给富文本进行渲染（不管是不是富文本 ），在渲染的时候按设置的聊天气泡的宽度进行换行，并且添加一个标记，当第一行富文本准备好的时候就可以隐藏思考视图，每次逐行从富文本缓存中读取一行的文本，刷新到聊天气泡内，并配合使用遮盖进行显示，显示完成后就读取下一行的富文本。根据以上要求和我提供的优化方案修改代码@富文本优化.md 