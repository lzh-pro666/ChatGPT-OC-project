# 文本显示不完全问题修复说明

## 问题描述

**现象**：控制台显示完整内容，但屏幕上只显示部分内容
- 控制台：`RichMessageCellNode: 处理第 0 个结果，isCodeBlock: NO, content: 你好！😊 很高兴见到你！有什么我可以帮忙的吗？无论是问题、建议，还是聊聊你的日常，都可以哦！`
- 屏幕显示：`你好！😊 很高兴见到你！有什么我可以帮忙的吗？无论是问题、建议，还是聊聊你的日`

**问题分析**：文本被截断，说明是布局宽度限制导致的显示问题

## 根本原因

### 1. 文本节点宽度限制
- 文本节点的 `flexGrow` 和 `flexShrink` 属性未正确设置
- 导致文本节点无法扩展到足够的宽度来显示完整内容

### 2. 布局约束问题
- 内容节点的布局约束设置不完整
- 栈布局的宽度计算不正确

### 3. 节点缓存问题
- 缓存的文本节点可能使用了旧的布局属性
- 新创建的节点没有正确的宽度设置

## 解决方案

### 1. 修复内容节点布局约束

#### 1.1 设置flex属性
```objc
- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize {
    // 关键修复：确保文本有足够的宽度显示完整内容
    CGFloat maxWidth = constrainedSize.max.width * 0.75;
    self.contentNode.style.maxWidth = ASDimensionMake(maxWidth);
    self.contentNode.style.minHeight = ASDimensionMakeWithPoints(0);
    // 关键修复：确保内容节点可以扩展以容纳完整文本
    self.contentNode.style.flexGrow = 1.0;
    self.contentNode.style.flexShrink = 1.0;
}
```

#### 1.2 设置栈布局flex属性
```objc
ASStackLayoutSpec *stack = [ASStackLayoutSpec stackLayoutSpecWithDirection:ASStackLayoutDirectionVertical
                                                                   spacing:8
                                                            justifyContent:ASStackLayoutJustifyContentStart
                                                                alignItems:ASStackLayoutAlignItemsStretch
                                                                  children:children];
// 关键修复：确保栈布局可以正确计算高度和宽度
stack.style.flexGrow = 1.0;
stack.style.flexShrink = 1.0;
```

### 2. 修复文本节点宽度设置

#### 2.1 占位符节点
```objc
if (children.count == 0) {
    ASTextNode *placeholderNode = [[ASTextNode alloc] init];
    placeholderNode.attributedText = [strongSelf attributedStringForText:(strongSelf.currentMessage ?: @"")];
    placeholderNode.maximumNumberOfLines = 0;
    // 关键修复：确保占位符节点可以显示完整文本
    placeholderNode.style.flexGrow = 1.0;
    placeholderNode.style.flexShrink = 1.0;
    children = @[placeholderNode];
}
```

#### 2.2 普通文本节点
```objc
- (ASTextNode *)getOrCreateTextNodeForText:(NSString *)text {
    NSString *cacheKey = [NSString stringWithFormat:@"text_%@", text];
    ASTextNode *cachedNode = self.nodeCache[cacheKey];
    
    if (!cachedNode) {
        cachedNode = [[ASTextNode alloc] init];
        cachedNode.attributedText = [self attributedStringForText:text];
        cachedNode.maximumNumberOfLines = 0;
        // 关键修复：确保文本节点可以显示完整内容
        cachedNode.style.flexGrow = 1.0;
        cachedNode.style.flexShrink = 1.0;
        self.nodeCache[cacheKey] = cachedNode;
    }
    
    return cachedNode;
}
```

#### 2.3 富文本节点
```objc
- (ASTextNode *)getOrCreateTextNodeForAttributedString:(NSAttributedString *)attributedString {
    NSString *cacheKey = [NSString stringWithFormat:@"attributed_%lu", (unsigned long)attributedString.hash];
    ASTextNode *cachedNode = self.nodeCache[cacheKey];
    
    if (!cachedNode) {
        cachedNode = [[ASTextNode alloc] init];
        cachedNode.attributedText = attributedString;
        cachedNode.maximumNumberOfLines = 0;
        // 关键修复：确保富文本节点可以显示完整内容
        cachedNode.style.flexGrow = 1.0;
        cachedNode.style.flexShrink = 1.0;
        self.nodeCache[cacheKey] = cachedNode;
    }
    
    return cachedNode;
}
```

#### 2.4 动态创建的文本节点
```objc
} else {
    // 创建文本节点
    NSLog(@"RichMessageCellNode: 创建文本节点");
    ASTextNode *textNode = [self getOrCreateTextNodeForAttributedString:result.attributedString];
    // 关键修复：确保文本节点可以显示完整内容
    textNode.style.flexGrow = 1.0;
    textNode.style.flexShrink = 1.0;
    
    // 关键调试：输出文本节点的宽度设置
    NSLog(@"RichMessageCellNode: 文本节点设置 - flexGrow: %.1f, flexShrink: %.1f", 
          textNode.style.flexGrow, textNode.style.flexShrink);
    
    if (![addedNodes containsObject:textNode]) {
        [childNodes addObject:textNode];
        [addedNodes addObject:textNode];
    }
}
```

### 3. 添加调试信息

#### 3.1 布局约束调试
```objc
// 关键调试：输出布局约束信息
NSLog(@"RichMessageCellNode: 布局约束 - maxWidth: %.1f, constrainedSize: %@", 
      maxWidth, NSStringFromCGSize(constrainedSize.max));
```

#### 3.2 文本节点设置调试
```objc
// 关键调试：输出文本节点的宽度设置
NSLog(@"RichMessageCellNode: 文本节点设置 - flexGrow: %.1f, flexShrink: %.1f", 
      textNode.style.flexGrow, textNode.style.flexShrink);
```

## 修复原理

### 1. Flexbox布局原理
- **flexGrow**: 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
- **flexShrink**: 定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
- **设置flexGrow = 1.0**: 允许文本节点占用所有可用空间
- **设置flexShrink = 1.0**: 允许文本节点在必要时缩小，但优先保持内容完整

### 2. 宽度计算流程
1. **内容节点**: 设置maxWidth为屏幕宽度的75%
2. **栈布局**: 垂直排列子节点，设置flexGrow = 1.0
3. **文本节点**: 设置flexGrow = 1.0，允许扩展到父容器宽度
4. **文本渲染**: 根据可用宽度计算换行，确保完整显示

### 3. 缓存节点处理
- 新创建的节点设置正确的flex属性
- 缓存的节点在创建时已经设置了正确的属性
- 确保所有文本节点都有正确的宽度设置

## 预期效果

### 1. 文本完整显示
- 长文本不再被截断
- 自动换行正确工作
- 气泡宽度自适应内容

### 2. 布局稳定性
- 文本节点宽度计算正确
- 避免布局时的宽度跳跃
- 保持视觉一致性

### 3. 性能优化
- 减少不必要的重新布局
- 缓存机制正常工作
- 滚动性能提升

## 测试要点

### 1. 长文本测试
- 发送包含长句子的消息
- 验证文本是否完整显示
- 检查自动换行是否正确

### 2. 特殊字符测试
- 包含emoji的消息
- 包含标点符号的长句
- 中英文混合内容

### 3. 布局稳定性测试
- 快速发送多条消息
- 滚动查看历史消息
- 验证布局是否稳定

## 总结

通过修复文本节点的flex属性设置，我们解决了文本显示不完全的问题：

1. **根本原因**: 文本节点的flexGrow和flexShrink属性未正确设置
2. **解决方案**: 为所有文本节点设置flexGrow = 1.0和flexShrink = 1.0
3. **修复范围**: 内容节点、栈布局、文本节点、占位符节点等
4. **预期效果**: 长文本完整显示，布局稳定，性能提升

这个修复确保了聊天界面能够正确显示完整的文本内容，提升了用户体验。

