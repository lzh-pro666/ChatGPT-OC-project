👌明白了，你需要一个**完整的语义块匹配逻辑**，用于把 ChatGPT API 的 SSE 流增量内容解析成“块”，而不是一个个 token。

这里我给你一个通用的 **语义分块规则集**（Markdown 友好型），它可以在客户端实时运行。

---

## 🎯 语义分块逻辑

### 1. 基本输入

* 输入：不断拼接的 `streamingBuffer`（SSE 增量拼起来的字符串）。
* 输出：`completedBlocks`（可以安全渲染的完整块）、`pendingBlock`（未闭合的部分）。

---

### 2. 块类型与边界条件

#### (1) 段落块

* **开始条件**：任意非空字符。
* **结束条件**：检测到连续 `\n\n`。
* **说明**：标准 Markdown 段落分隔符。

#### (2) 标题块

* **开始条件**：行首匹配 `^#{1,6} `。
* **结束条件**：遇到换行符 `\n`。
* **说明**：标题是单行结构，不需要等到 `\n\n`。

#### (3) 列表块

* **开始条件**：行首匹配 `^(-|\*|\d+\.) `。
* **结束条件**：下一行不是列表项，或遇到空行 `\n\n`。
* **说明**：列表可以多行组成，需要动态检测。

#### (4) 引用块

* **开始条件**：行首匹配 `^> `.
* **结束条件**：下一行不是 `^> `，或遇到空行 `\n\n`。

#### (5) 代码块（Fenced Block）

* **开始条件**：检测到行首 ` ``` `。
* **结束条件**：检测到下一个 ` ``` `。
* **说明**：未闭合时，该块进入 `pendingBlock`，不要渲染。

#### (6) 内联代码块

* **开始条件**：单反引号 `` ` ``。
* **结束条件**：匹配到成对的 `` ` ``。
* **说明**：如果还没闭合，算 `pendingBlock`。

#### (7) 普通文本行

* **开始条件**：任意字符。
* **结束条件**：`\n`。
* **说明**：在没有明确语义块时，作为 fallback。

---

### 3. 匹配优先级

1. **代码块 fenced**（最高优先级，防止里面的 `\n` 被误当段落）。
2. **标题/列表/引用**（块级语法）。
3. **内联代码**。
4. **段落/普通行**（兜底）。

---

### 4. 处理流程（伪代码）

```objc
NSMutableArray *completedBlocks = [NSMutableArray array];
NSMutableString *pendingBuffer = [NSMutableString string];

- (void)appendChunk:(NSString *)delta {
    [pendingBuffer appendString:delta];

    while (true) {
        BlockParseResult *result = [self tryParseBlockFrom:pendingBuffer];
        if (result.completed) {
            [completedBlocks addObject:result.block];
            [pendingBuffer deleteCharactersInRange:result.range]; // 移除已消费
        } else {
            break; // 没有完整块可解析，等待更多 delta
        }
    }
}
```

---

### 5. `tryParseBlockFrom:` 逻辑

1. **如果在 fenced code block 中**

   * 搜索下一个 ` ``` `，找到则返回完整 block；否则 return `pending`。

2. **如果匹配到标题（`^#{1,6} `）**

   * 找到下一次 `\n` → 截取为标题块。


3. **如果匹配到引用块（`^> `）**

   * 同列表逻辑，直到遇到非引用行或 `\n\n`。

4. **如果检测到段落（非空文本）**

   * 收集到 `\n\n` → 返回段落块。

5. **如果都不满足**

   * return `pending`。

---

### 6. 性能优化

* **后台线程**：所有正则匹配和行切分在 `NSOperationQueue`（userInitiated QoS）执行。
* **增量解析**：避免每次都重新解析 `streamingBuffer`，只解析新增部分。
* **缓存块**：对已完成的 block 生成 `NSAttributedString` 缓存，避免重复渲染。

---

✅ 总结：

* 核心思想：**SSE → 增量拼接 → 块解析器。
* 这样保证了：

  1. 已闭合的块（标题、段落、代码块）能逐行显示；
  2. 未闭合的块不会提前闪烁；
  3. 性能可控，主要计算在后台线程，主线程只做排版。

---

