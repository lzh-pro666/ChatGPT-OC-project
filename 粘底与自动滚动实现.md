### 粘底与自动滚动实现（ChatDetailViewControllerV2）

本文详细说明消息列表的“粘底（自动滚动到最底部）”与相关联动逻辑，包括：什么时候判断需要粘底、触发源、如何计算滚动目标偏移、每次滚动的距离/方式、防抖与暂停策略等。

---

## 关键常量与状态
- 常量（`ChatDetailViewControllerV2.m` 顶部）：
  - `kAutoScrollBottomTolerance = 120.0`：判定“接近底部”的容差（像素）。
  - `kContentHeightIncreaseThreshold = 10.0`：内容高度显著增长阈值（触发锚定）。
  - `kAutoScrollDebounceSeconds = 0.02`：自动粘底防抖时间（秒）。
- 状态：
  - `userIsDragging`：用户是否正在拖动列表。
  - `codeBlockInteracting`：代码块内横向滚动交互中。
  - `isDecelerating`：列表减速中。
  - `pendingAutoScrollTask`：待执行的粘底任务（事件驱动 + 防抖）。
  - `stickOnKeyboardChange`：键盘联动期间是否需要粘底（仅接近底部时）。

---

## “接近底部”的判断
- 方法：`isNearBottomWithTolerance:`
- 核心计算：
  - `visibleBottomY = offsetY + viewHeight - bottomInset`
  - `effectiveContentBottomY = contentHeight - bottomInset`
  - 当 `visibleBottomY >= effectiveContentBottomY - tolerance` 为“接近底部”。
- 容差：统一使用 `kAutoScrollBottomTolerance`（120pt），使粘底更宽松和稳定。

---

## 何时需要粘底（shouldPerformAutoScroll）
- 方法：`shouldPerformAutoScroll`
- 会在以下情况返回 NO（不自动滚动）：
  - 用户正在拖动（`userIsDragging`）。
  - 输入框是第一响应者但当前不在底部（避免输入时被拉回到底部）。
  - 正在减速（`isDecelerating`）。
  - 代码块交互中（`codeBlockInteracting`）。
- 其他情况：
  - 内容未满一屏：仅在接近底部时滚动。
  - 内容超过一屏：接近底部时滚动。

---

## 自动滚动的统一入口
- 方法：`performAutoScrollWithContext:animated:`（内部也提供不带 `animated` 的委托版本）。
- 步骤：
  1) 若 `shouldPerformAutoScroll` 为否或 `tableNode.view` 不可用/未进窗口，则直接返回。
  2) 读取当前 `contentOffset` 与目标偏移 `targetOffset`（见下文）。
  3) 若两者差值小于 1pt，放弃滚动；否则调用 `setContentOffset:targetOffset animated:animated`。
- 动画：
  - 可选 `animated`，多数逻辑走无动画以减少抖动。

---

## 目标偏移与每次滚动的“距离”
- 方法：`_bottomContentOffsetForTable:`
- 计算：
  - `visibleHeight = viewHeight - adjustedContentInset.bottom`
  - `targetOffsetY = contentHeight - visibleHeight`
  - `minOffsetY = -adjustedContentInset.top`
  - 目标 `y` 在 `[minOffsetY, targetOffsetY]` 范围内，并保持 `x` 不变。
- “每次滚动的距离”即 `|currentOffset.y - targetOffset.y|`，由实时内容高度与 inset 动态决定；控制器不做分段插值或速率控制，交由 `UITableView`（若 animated=YES）或一次性设置（animated=NO）。

---

## 触发源（事件驱动 + 防抖）
- 逐行渲染：`handleRichMessageAppendLine:` → `requestBottomAnchorWithContext:@"handleRichMessageAppendLine"`
- 首行即将追加：`handleRichMessageWillAppendFirstLine:` → 预先锚定，避免“空白气泡”
- 控制器批处理更新：`performUpdatesPreservingBottom:` → 更新后合并一次锚定
- 键盘变化：`keyboardWillShow/Hide` 若进入前“接近底部”，则在动画中 `performAutoScrollWithContext` 保持底部可见
- 内容高度显著增加（KVO `contentSize`）：当 `heightIncrease > kContentHeightIncreaseThreshold`，触发 `requestBottomAnchorWithContext:@"contentSizeChanged"`

> 防抖：`requestBottomAnchorWithContext:` 内部使用 `dispatch_after` + `kAutoScrollDebounceSeconds` 合并多次触发，避免频繁 `setContentOffset`。

---

## 与用户交互的协调
- `scrollViewWillBeginDragging:`：
  - 标记 `userIsDragging = YES`；
  - 调用 `pauseUIUpdates`（暂停富文本逐行动画与 UI 更新）；
  - 取消当前待执行的粘底任务，避免与用户手势“抢滚动”。
- `scrollViewDidEndDragging:willDecelerate:` / `scrollViewDidEndDecelerating:`：
  - 清除 `userIsDragging` / `isDecelerating` 标记；
  - 调用 `resumeUIUpdates` 恢复逐行动画并继续渲染。
- 代码块横向滚动：
  - `CodeBlockPanBegan` → `pauseUIUpdates`；`CodeBlockPanEnded` → `resumeUIUpdates`。

---

## 与首包/错误流程的配合
- 首包时（仍处于思考态）：插入空 AI 行与答案行前后，调用 `anchorScrollToBottomIfNeeded` 确保始终贴底。
- 错误/取消：在移除“思考行”、插入错误消息或追加错误后缀时，均调用 `anchorScrollToBottomIfNeeded`；具体是否滚动仍由 `shouldPerformAutoScroll` 判断。

---

## 代码索引（便于快速定位）
- 接近底部判断：`isNearBottomWithTolerance:`
- 自动滚动判定：`shouldPerformAutoScroll`
- 统一滚动入口：`performAutoScrollWithContext:animated:` / `ensureBottomVisible:`
- 目标偏移计算：`_bottomContentOffsetForTable:`
- 事件驱动 + 防抖：`requestBottomAnchorWithContext:`
- 批处理后粘底：`performUpdatesPreservingBottom:`
- 交互暂停/恢复：`pauseUIUpdates` / `resumeUIUpdates`、`scrollView*` delegate、`_onCodeBlockPanBegan/_onCodeBlockPanEnded`

---

## 小结
该粘底实现采用“事件驱动 + 防抖”的策略，在“接近底部”的条件下对新增内容进行按需锚定，兼顾了逐行渲染的平滑性与用户手势的主导权。滚动目标通过内容尺寸与 inset 计算得到，距离随内容变化而自动适配；在键盘显示、代码块展开、富文本逐行更新等情况下，都能稳定保持底部可见，同时避免抖动与抢滚动。
