## 滚动与渲染性能优化说明（2025-09-12）

### 背景与症状
- 聊天流式渲染过程中，用户上下滑动不够跟手，Instruments 中 `__CFRunLoopDoSources0` / `__CFRunLoopDoObservers` 占比高，但 CPU 并不高。
- 根因：主线程频繁被小而多的 UI 任务唤醒（逐行通知、contentSize KVO、插入行后的自动粘底、同步布局），触摸事件无法在每帧准时处理，造成掉帧和响应延迟。

### 目标
1) 降低主线程 RunLoop 事件风暴；2) 减少同步布局；3) 稳定气泡宽度、避免重复测量；4) 保证用户滑动时不被“自动粘底”打断。

---

### 已实施优化

#### 1) 粘底滚动改为“帧级合并”
- 文件：`ChatDetailViewControllerV2.m`
- 新增：
  - 属性：`CADisplayLink *bottomAnchorLink`、`BOOL needsBottomAnchor`
  - 方法：`requestBottomAnchorWithContext:`、`_onBottomAnchorTick:`
- 调整：将以下触发改为“提交请求 → 下一帧统一滚动”，避免每次追加/高度变化都立即滚动：
  - `anchorScrollToBottomIfNeeded`
  - `throttledEnsureBottomVisible`
  - `handleRichMessageAppendLine:` / `handleRichMessageWillAppendFirstLine:`
  - contentSize KVO（高度显著增长）
  - `throttledAutoScrollWithContext:`（内部改为走合并器）
- 仍通过 `shouldPerformAutoScroll` 避免用户拖动/代码块横滑时的自动滚动。

#### 2) 减少同步布局（layoutIfNeeded）
- 文件：`ChatDetailViewControllerV2.m`、`RichMessageCellNode.m`
- 删除/避免在流式回调和批量更新中的 `layoutIfNeeded`，改为：
  - 仅 `setNeedsLayout`，由 Texture/下一帧进行布局。
  - `performUpdatesPreservingBottom:` 不再做同步 `layoutIfNeeded` 和内容高度差值计算，改为直接提交“帧级粘底请求”。

#### 3) 逐行通知“帧级合并”
- 文件：`RichMessageCellNode.m`
- 新增：
  - 属性：`CADisplayLink *lineNotifyLink`、`BOOL pendingLineNotify`
  - 方法：`scheduleBatchedLineNotification`、`_onLineNotifyTick:`
- 将每行一次的 `RichMessageCellNodeDidAppendLine` 改为每帧最多一次发送，显著减少通知风暴。

#### 4) 逐行渲染节流（双保险）
- 文件：`RichMessageCellNode.m`
- 新增属性：`minLineRenderInterval`（默认 50ms）和 `lastLineRenderTime`，在 `scheduleNextLineTask` 中保证相邻两行间隔 `max(baseInterval, minInterval)`。

#### 5) 聊天气泡宽度稳定化 + 单行自适应
- 文件：`RichMessageCellNode.m`（`layoutSpecThatFits:`）
- 规则：
  - 默认固定为 `capWidth = min(表格允许宽度, 屏幕宽度 × 0.75)`，并同时设置 `width/minWidth/maxWidth = capWidth`，关闭 `flexGrow/flexShrink`。
  - 当“仅一个文本渲染节点且无换行”时（包含带图片场景的纯文本引导语）：按文本自然宽度收窄到 `[60pt, capWidth]`，并同样三件套固定宽度，减少重复测量。

#### 6) 首次 reload 延后与 window 守卫
- 文件：`ChatDetailViewControllerV2.m`
- 新增：`didInitialAppear` 标记；将首次 `reloadData` 移至 `viewDidAppear` 执行，进入窗口后再贴底滚动。
- 在 `performAutoScrollWithContext:` / `forceScrollToBottomAnimated:` 中增加 `tv.window` 判定：未进入窗口直接返回，消除“在层级外布局”的警告与额外开销。

---

### 智能滚动性能评估
- 现实现：每帧最多一次 `setContentOffset`，并带 `shouldPerformAutoScroll` 防抖，属于低开销。
- 可选增强（未启用）：在 displayLink tick 中加入“同位容差检查”（例如 2～4pt），避免重复设置同一 offset。

### 对用户滑动的友好性
- 用户开始拖动 `scrollViewWillBeginDragging:` → `pauseUIUpdates`，暂停逐行推进/动画。
- 松手或减速结束再 `resumeUIUpdates`，并通过帧级粘底保证回到底部的时序自然。

---

### 观察到的收益
- Instruments 中 RunLoop Source/Observer 的尖峰被明显削弱；手势响应更顺滑。
- 消除了 UITableView 在未加入 window 时的提前布局警告。
- 气泡宽度稳定，单行文案（包括“带图片发送/图片生成回复”等场景）视觉更紧凑，减少无谓的宽度测量与重排。

---

### 回归检查清单
- 流式文本：逐行渲染节奏是否平滑，粘底是否只在接近底部时发生。
- 带长代码块：内容扩展时，底部自动锚定是否顺畅，横向滚动代码块时不会自动滚动。
- 首次进入聊天：无布局警告、无闪动；历史消息加载完成后能贴底。
- 单行文本（含带图片场景）：气泡宽度是否按文本宽度自适应且不超过 75% 屏宽。

---

### 后续可选优化（建议）
- 粘底合并器中加入“offset 容差检查”，避免同位重复设置。
- 为单行宽度测量增加简单 LRU 缓存（按文本长度区间），进一步减少重复计算。
- 在用户滚动中暂时放大 `lineRenderInterval`（例如 ×1.5～2.0），放手后恢复，进一步让位手势。



