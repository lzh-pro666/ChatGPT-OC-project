# 闪烁和宽度优化说明

## 问题分析

### 1. 闪烁问题
- **原因**：频繁的布局重新计算导致界面闪烁
- **表现**：打字机效果更新时出现视觉抖动
- **影响**：用户体验不佳，视觉疲劳

### 2. 宽度适配问题
- **原因**：文本节点没有设置最大宽度约束
- **表现**：消息宽度超出屏幕范围
- **影响**：布局不美观，可读性差

## 优化方案

### 1. 宽度适配优化

**添加最大宽度约束**：
```objective-c
// 设置文本节点的最大宽度，确保适配屏幕
CGFloat maxWidth = constrainedSize.max.width * 0.75;
textNode.style.maxWidth = ASDimensionMake(maxWidth);
```

**效果**：
- 消息宽度限制在屏幕宽度的 75%
- 自动换行，保持良好的可读性
- 适配不同屏幕尺寸

### 2. 闪烁优化

**异步布局更新**：
```objective-c
// 使用异步更新避免闪烁
dispatch_async(dispatch_get_main_queue(), ^{
    [self setNeedsLayout];
});
```

**防抖动机制优化**：
```objective-c
// 增加延迟时间减少闪烁
[self performSelector:@selector(performMessageUpdate:) withObject:message afterDelay:0.1];
```

**打字机效果优化**：
```objective-c
// 增加字符块大小和间隔时间
static const NSInteger kTypingSpeedCharacterChunk = 8;  // 从 5 增加到 8
static const NSTimeInterval kTypingTimerInterval = 0.12; // 从 0.08 增加到 0.12
```

### 3. 性能优化

**移除调试日志**：
- 减少不必要的 NSLog 调用
- 降低性能开销
- 提高渲染效率

## 优化效果

### 宽度适配
- ✅ 消息宽度适配屏幕
- ✅ 自动换行功能
- ✅ 保持良好的可读性

### 闪烁控制
- ✅ 减少布局重新计算频率
- ✅ 平滑的打字机效果
- ✅ 更好的视觉体验

### 性能提升
- ✅ 减少不必要的日志输出
- ✅ 优化布局计算
- ✅ 提高整体响应速度

## 技术细节

### 宽度约束
```objective-c
// 计算最大宽度
CGFloat maxWidth = constrainedSize.max.width * 0.75;

// 应用约束
textNode.style.maxWidth = ASDimensionMake(maxWidth);
```

### 防抖动机制
```objective-c
// 取消之前的更新
[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(performMessageUpdate:) object:nil];

// 延迟执行新更新
[self performSelector:@selector(performMessageUpdate:) withObject:message afterDelay:0.1];
```

### 异步布局
```objective-c
// 异步更新避免阻塞主线程
dispatch_async(dispatch_get_main_queue(), ^{
    [self setNeedsLayout];
});
```

## 测试要点

1. **宽度测试**：
   - 长文本消息是否正确换行
   - 不同屏幕尺寸下的显示效果
   - 用户和AI消息的对齐效果

2. **闪烁测试**：
   - 打字机效果是否平滑
   - 是否有明显的视觉抖动
   - 滚动时的稳定性

3. **性能测试**：
   - 大量消息时的响应速度
   - 内存使用情况
   - 电池消耗

## 注意事项

- 保持优化后的稳定性
- 监控性能指标
- 根据实际使用情况调整参数
- 避免过度优化影响功能
