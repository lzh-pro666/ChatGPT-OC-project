# 文本显示问题修复说明

## 问题描述

富文本消息节点没有显示文字内容。

## 问题分析

1. **初始化顺序问题**：在 `RichMessageCellNode` 初始化时，先调用了 `updateContentNode`，然后才调用 `parseMessage`，导致 `parsedResults` 为空
2. **布局规范问题**：可能存在 ASDK 布局规范的使用问题
3. **解析逻辑复杂**：Markdown 解析逻辑可能过于复杂，导致解析失败

## 修复方案

### 1. 修复初始化顺序

**修改前**：
```objective-c
// 设置内容节点的布局规范
[self updateContentNode];

// 解析消息内容
[self parseMessage:message];
```

**修改后**：
```objective-c
// 解析消息内容
[self parseMessage:message];

// 设置内容节点的布局规范
[self updateContentNode];
```

### 2. 简化解析逻辑

暂时移除复杂的 Markdown 解析，只保留基本文本显示：

```objective-c
- (void)parseMessage:(NSString *)message {
    // 简化版本：先确保基本文本显示正常
    NSLog(@"RichMessageCellNode: parseMessage called with: %@", message);
    
    NSMutableArray<ParserResult *> *results = [NSMutableArray array];
    
    // 创建一个简单的解析结果
    ParserResult *result = [[ParserResult alloc] init];
    result.isCodeBlock = NO;
    result.attributedString = [self attributedStringForText:message];
    [results addObject:result];
    
    self.parsedResults = [results copy];
    NSLog(@"RichMessageCellNode: parsedResults count: %lu", (unsigned long)self.parsedResults.count);
    
    [self updateContentNode];
}
```

### 3. 简化富文本处理

暂时移除 Markdown 样式处理，只保留基础样式：

```objective-c
- (NSAttributedString *)attributedStringForText:(NSString *)text {
    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    paragraphStyle.lineSpacing = 4;
    paragraphStyle.lineBreakMode = NSLineBreakByWordWrapping;
    
    UIColor *textColor = self.isFromUser ? [UIColor whiteColor] : [UIColor blackColor];
    
    // 简化版本：只应用基础样式
    NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:text];
    
    [attributedString addAttributes:@{
        NSParagraphStyleAttributeName: paragraphStyle,
        NSFontAttributeName: [UIFont systemFontOfSize:16],
        NSForegroundColorAttributeName: textColor
    } range:NSMakeRange(0, attributedString.length)];
    
    return [attributedString copy];
}
```

### 4. 添加调试信息

在关键方法中添加 NSLog 调试信息：

```objective-c
NSLog(@"RichMessageCellNode: parseMessage called with: %@", message);
NSLog(@"RichMessageCellNode: parsedResults count: %lu", (unsigned long)self.parsedResults.count);
NSLog(@"RichMessageCellNode: updateContentNode called");
```

### 5. 添加容错处理

在 `updateContentNode` 中添加容错处理：

```objective-c
// 如果没有解析结果，创建一个默认的文本节点
if (self.parsedResults.count == 0) {
    ASTextNode *defaultTextNode = [[ASTextNode alloc] init];
    defaultTextNode.attributedText = [[NSAttributedString alloc] initWithString:self.currentMessage ?: @""];
    defaultTextNode.maximumNumberOfLines = 0;
    [childNodes addObject:defaultTextNode];
}

// 如果没有子节点，创建一个空的占位符
if (childNodes.count == 0) {
    ASTextNode *placeholderNode = [[ASTextNode alloc] init];
    placeholderNode.attributedText = [[NSAttributedString alloc] initWithString:@"(空消息)"];
    placeholderNode.maximumNumberOfLines = 0;
    [childNodes addObject:placeholderNode];
}
```

## 测试步骤

1. **编译运行**：确保没有编译错误
2. **查看控制台**：检查调试日志输出
3. **验证显示**：确认文本是否正确显示
4. **逐步恢复**：在基本功能正常后，逐步添加 Markdown 功能

## 预期结果

- 消息应该能正常显示文本内容
- 控制台应该能看到调试日志
- 如果没有内容，应该显示 "(空消息)" 占位符

## 下一步计划

1. **基本文本显示正常后**，重新添加 Markdown 解析
2. **逐步添加功能**：粗体、斜体、行内代码
3. **最后添加代码块**：使用专门的代码块视图

## 注意事项

- 确保 ASDK 布局规范正确使用
- 避免重复使用布局规范对象
- 添加足够的调试信息帮助诊断问题
