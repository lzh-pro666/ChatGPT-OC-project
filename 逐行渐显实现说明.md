# 逐行渐显效果实现说明

## 🎯 实现目标

基于用户反馈，重新设计丝滑渐显效果，实现真正的 **逐行渐显** 而不是整个气泡闪烁：

1. **逐行渐显**：新内容一行一行渐显出来，已显示的文本不闪烁
2. **正确滚动**：发送消息时滚动到新消息，流式更新时滚动到当前AI消息
3. **无空白气泡**：思考视图与富文本节点无缝切换，避免中间空白状态

## 🔧 核心技术方案

### 1. 逐行渐显动画
- 使用 `CADisplayLink` 实现 60fps 流畅动画
- 每行延迟 100ms 出现，创造逐行渐显效果
- 已显示的节点保持可见，只对新节点应用渐显

### 2. 智能滚动策略
- 用户发送消息：滚动到新添加的用户消息
- 思考视图显示：滚动到思考视图位置
- 流式更新：滚动到当前正在更新的AI消息
- 流式完成：滚动到完整的AI回复

### 3. 无缝状态切换
- 先创建富文本节点，确保内容准备好
- 使用无动画切换，避免视觉跳跃
- 等待节点布局完成后再切换UI

## 📱 实现细节

### RichMessageCellNode 逐行渐显逻辑

```objc
// 应用逐行渐显到指定节点
- (void)applyLineByLineFadeInToNode:(ASDisplayNode *)node atIndex:(NSInteger)index {
    // 关键改进：只对新节点应用渐显，已显示的节点保持不变
    if (node.alpha >= 1.0) {
        return; // 节点已经完全可见，跳过
    }
    
    // 设置节点初始状态为透明
    node.alpha = 0.0;
    
    // 创建渐显动画
    CABasicAnimation *fadeInAnimation = [CABasicAnimation animationWithKeyPath:@"opacity"];
    fadeInAnimation.fromValue = @(0.0);
    fadeInAnimation.toValue = @(1.0);
    fadeInAnimation.duration = 0.4; // 400ms的渐显时间，更平滑
    fadeInAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
    fadeInAnimation.fillMode = kCAFillModeForwards; // 保持最终状态
    fadeInAnimation.removedOnCompletion = NO; // 不移除动画
    
    // 为每个节点设置不同的延迟，创造逐行出现的效果
    fadeInAnimation.beginTime = CACurrentMediaTime() + (index * 0.1); // 每行延迟100ms
    
    // 应用动画
    [node.layer addAnimation:fadeInAnimation forKey:[NSString stringWithFormat:@"fadeIn_%ld", (long)index]];
    
    // 立即设置最终状态，避免闪烁
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        node.alpha = 1.0;
    });
}
```

### 智能滚动策略实现

```objc
// 关键修复：滚动到当前正在更新的AI消息，而不是最后一条消息
NSIndexPath *currentAINodePath = [self getCurrentAINodeIndexPath];
if (currentAINodePath) {
    [self.tableNode scrollToRowAtIndexPath:currentAINodePath atScrollPosition:UITableViewScrollPositionBottom animated:NO];
    NSLog(@"智能滚动：滚动到当前AI消息");
} else {
    // 如果找不到当前AI节点，则滚动到最后一条消息
    NSIndexPath *lastIndexPath = [NSIndexPath indexPathForRow:self.messages.count - 1 inSection:0];
    [self.tableNode scrollToRowAtIndexPath:lastIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:NO];
    NSLog(@"智能滚动：滚动到最后一条消息");
}
```

### 无缝状态切换实现

```objc
// 关键改进：先创建富文本节点，确保内容准备好后再切换
if (kUseRichMessageCell) {
    RichMessageCellNode *richNode = [[RichMessageCellNode alloc] initWithMessage:partialResponse isFromUser:NO];
    strongSelf->_currentUpdatingAINode = richNode;
    
    // 关键优化：等待富文本节点准备完成后再切换UI
    [richNode setNeedsLayout];
    [richNode layoutIfNeeded];
    
    // 关键修复：使用无动画切换，避免空白状态，并确保滚动到正确位置
    [strongSelf.tableNode performBatchUpdates:^{
        [strongSelf.tableNode deleteRowsAtIndexPaths:@[thinkingIndexPath] withRowAnimation:UITableViewRowAnimationNone];
        [strongSelf.tableNode insertRowsAtIndexPaths:@[finalMessagePath] withRowAnimation:UITableViewRowAnimationNone];
    } completion:^(BOOL finished) {
        if(finished) {
            // 关键修复：滚动到新创建的AI消息，而不是思考视图的位置
            [strongSelf.tableNode scrollToRowAtIndexPath:finalMessagePath atScrollPosition:UITableViewScrollPositionBottom animated:YES];
            
            // 启动打字机定时器
            [strongSelf startTypingTimer];
        }
    }];
}
```

## 🚀 性能优化

### 1. 动画节流
- 动画更新频率：每 100ms 更新一次（给用户足够时间阅读）
- 逐行延迟：每行延迟 100ms 出现
- 渐显时间：400ms 的平滑渐显

### 2. 智能节点管理
- 只对新节点应用渐显，已显示节点保持不变
- 使用 `fillMode = kCAFillModeForwards` 保持动画最终状态
- 动画完成后移除所有动画，释放资源

### 3. 滚动优化
- 使用节流机制，避免频繁滚动
- 智能判断滚动目标位置
- 无动画滚动减少视觉跳跃

## 🎨 视觉效果

### 逐行渐显动画
- **持续时间**: 400ms
- **缓动函数**: `kCAMediaTimingFunctionEaseOut`
- **帧率**: 60fps
- **透明度**: 0.0 → 1.0
- **逐行延迟**: 每行延迟 100ms

### 状态切换流程
1. **思考状态**: 显示加载动画，滚动到思考视图
2. **流式开始**: 创建富文本节点，无动画切换UI
3. **逐行渐显**: 新内容一行一行平滑出现
4. **完成状态**: 所有内容完全可见，滚动到完整回复

## 🔍 问题解决

### 1. 整个气泡闪烁 ✅
- 改为逐行渐显，每行独立动画
- 已显示节点保持可见，不重新应用动画
- 使用延迟创造自然的逐行出现效果

### 2. 滚动位置错误 ✅
- 用户发送消息：滚动到新用户消息
- 思考视图：滚动到思考视图位置
- 流式更新：滚动到当前AI消息
- 流式完成：滚动到完整AI回复

### 3. 空白气泡问题 ✅
- 先创建富文本节点，确保内容准备好
- 等待节点布局完成后再切换UI
- 使用无动画切换，避免中间空白状态

## 📋 使用方法

### 启用逐行渐显
```objc
// 自动检测流式模式并启动逐行渐显
[richNode updateMessageText:newMessage];
```

### 完成流式更新
```objc
// 流式更新完成时自动处理
[richNode completeStreamingUpdate];
```

### 智能滚动
```objc
// 自动滚动到正确位置
[self.tableNode scrollToRowAtIndexPath:targetPath atScrollPosition:UITableViewScrollPositionBottom animated:YES];
```

## 🎯 效果预期

1. **逐行渐显**: 新内容一行一行平滑出现，已显示内容不闪烁
2. **正确滚动**: 发送消息和流式更新时都滚动到正确位置
3. **无空白状态**: 思考视图与富文本节点无缝切换
4. **流畅体验**: 400ms 平滑渐显，100ms 逐行延迟
5. **高性能**: 60fps 流畅动画，智能节流和缓存

## 🔧 调试信息

启用详细日志输出：
```objc
NSLog(@"RichMessageCellNode: 启动逐行渐显动画");
NSLog(@"RichMessageCellNode: 第 %ld 行渐显完成", (long)index);
NSLog(@"RichMessageCellNode: 逐行渐显动画完成");
NSLog(@"智能滚动：滚动到当前AI消息");
NSLog(@"智能滚动：滚动到最后一条消息");
```

通过日志可以监控：
- 逐行渐显进度
- 滚动目标位置
- 状态切换状态
- 动画执行情况
